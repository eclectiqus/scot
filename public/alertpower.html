
<!DOCTYPE html>
<meta charset='utf-8'>
<style>
    body {
        font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        position: relative;
    }
    text{
        font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }
    .toolTip {
        font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        position: absolute;
        display: none;
        width: auto;
        height: auto;
        background: none repeat scroll 0 0 white;
        border: 0 none;
        border-radius: 8px 8px 8px 8px;
        box-shadow: -3px 3px 15px #888888;
        color: black;
        font: 12px sans-serif;
        padding: 5px;
        text-align: center;
    }
    .legend {
        font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        font-size: 60%;
    }
    text {
        font: 10px sans-serif;
    }
    .axis text {
        font: 10px sans-serif;
    }
    .axis path{
        fill: none;
        stroke: #000;
    }
    .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }
    .x.axis path {
        display: none;
    }
</style>
<body>

<script src='https://d3js.org/d3.v4.min.js'></script>
<script>
	const wrapText = ( text, width ) => {
        text.each( function() {
			if ( this.getComputedTextLength() < width ) {
				return;
			}

            var text = d3.select(this),
				words = text.text().split(/\s+/).reverse(),
				word = null,
				line = [],
				lineNumber = 0,
				lineHeight = 0.8, // ems
				x = text.attr( 'x' ),
				y = text.attr( 'y' ),
				dy = parseFloat( text.attr( 'dy' ) ),
				row = text
					.text( null )
					.append( 'tspan' )
					.attr( 'x', x )
					.attr( 'y', y )
					.attr( 'dy', dy + 'em' );

            while ( word = words.pop() ) {
                line.push( word );
                row.text( line.join( ' ' ) );
                if ( row.node().getComputedTextLength() > width ) {
                    line.pop();
                    row.text( line.join( ' ' ) );
                    line = [ word ];
					row = text
						.append( 'tspan' )
						.attr( 'x', x )
						.attr( 'y', y )
						.attr( 'dy', ++lineNumber * lineHeight + dy + 'em' )
						.text( word );
                }
            }

			let numLines = lineNumber + 1;
			let yOffset = this.getBBox().height / ( 2 * numLines ) * ( numLines - 1 );
			text.attr( 'transform', `translate( 0, -${yOffset} )` );
        });
    }

/*    dataset = [
        {label:'Art and Humanities', 'Not Satisfied':25, 'Not Much Satisfied':40, 'Satisfied': 15, 'Very Satisfied':20},
        {label:'Sciences', 'Not Satisfied':5, 'Not Much Satisfied':30, 'Satisfied': 50, 'Very Satisfied':15},
        {label:'Health Sciences', 'Not Satisfied':20, 'Not Much Satisfied':30, 'Satisfied': 40, 'Very Satisfied':10},
        {label:'Social Sciences', 'Not Satisfied':10, 'Not Much Satisfied':40, 'Satisfied': 45, 'Very Satisfied':5},
        {label:'Architecture and Engineering', 'Not Satisfied':5, 'Not Much Satisfied':15, 'Satisfied': 40, 'Very Satisfied':40},
    ];
*/
    var url = '/scot/api/v2/metric/alert_power';
    var opts= '?type=all';
    
    var margin = {
			top: 20, left: 200, right: 20, bottom: 80,
        },
        width = 1000 - margin.left - margin.right,
        height = 700 - margin.top - margin.bottom;

    // x is the normal 'y' axis since this is a horizontal bar graph
    var x   = d3.scaleLinear().rangeRound([width, 0]);
	var y   = d3.scaleBand().rangeRound([0,height])
		.padding( .3 );

    var color       = d3.scaleOrdinal( d3.schemeCategory20 );

    var xAxis   = d3.axisBottom()
                    .scale(x)
                    .tickFormat(d3.format( '.2s' ));

    var yAxis   = d3.axisLeft()
                    .scale(y);

    var svg     = d3.select( 'body' )
                    .append( 'svg' )
						.attr( 'viewBox', '0 0 1000 700' )
                    .append( 'g' )
                    .attr( 'transform', 'translate( ' + margin.left +','+ margin.top +' )' );

    var divTooltip  = d3.select( 'body' )
                        .append( 'div' )
                        .attr( 'class', 'toolTip' );

    d3.json(url+opts, function(dataset) {

        color.domain(
            d3.keys(dataset[0])
              .filter(function(key){ return key !== 'date'; })
        );

        dataset.forEach(function(d) {
            var x0  = 0;
            d.values = color.domain()
                            .map(function(name){ return {name: name, x0: x0, x1: x0+= +d[name]}; });
            d.total = d.values[d.values.length - 1].x1;
        });

        x.domain([0, d3.max(dataset, function(d) { return d.total; })]);
        y.domain(dataset.map(function(d) { return d.date; }));

        svg.append( 'g' )
           .attr( 'class', 'x axis' )
           .attr( 'transform', 'translate(0,' + height + ' )' )
           .call(xAxis)
           .attr( 'y', 9)
           .attr( 'dy', '.71em' )
           .style( 'text-anchor', 'end' )
           .text( 'Alert Count' );

        svg.append( 'g' )
           .attr( 'class', 'y axis' )
           .call(yAxis);

        var bar = svg.selectAll( '.label' )
                     .data(dataset)
                     .enter()
                     .append( 'g' )
                     .attr( 'class', 'g' )
                     .attr( 'transform', function(d) {
                        return 'translate(0,'+y(d.date)+' )'; });

        svg.selectAll( '.y.axis .tick text' ).call(wrapText, margin.left - 20);
        // svg.selectAll( '.y.axis .tick text' );

        var bar_enter   = bar.selectAll( 'rect' )
                             .data(function(d){return d.values; })
                             .enter();

        bar_enter.append( 'rect' )
                 .attr( 'height', y.bandwidth())
                 //.attr( 'x', function(d) { return x(d.x1); })
                 .attr( 'x', function(d) { return +0; })
                 .attr( 'width', function(d) { return x(d.x0) - x(d.x1); })
                 .style( 'fill', function(d) { return color(d.name); });

        bar_enter.append( 'text' )
                 .text(function(d) { return d3.format( '.2s' )(d.x1-d.x0)+''; })
                 .attr( 'y', function(d) { return x(d.x1)+(x(d.x0) -x(d.x1))/2; })
                 .attr( 'x', y.bandwidth()/3)
                 .style( 'fill', '#ffffff' );

        bar.on( 'mousemove', function(d) {
            divTooltip.style( 'left', d3.event.pageX+10+'px' );
            divTooltip.style( 'top',  d3.event.pageY-25+'px' );
            divTooltip.style( 'display', 'inline-block' );
            var elements = document.querySelectorAll( ':hover' );
            l = elements.length;
            l = l - 1;
            element = elements[l].__data__;
            value = element.x1 - element.x0;
            divTooltip.html((d.date)+'<br>'+element.name+'<br>'+value+'' );
        });

        bar.on( 'mouseout', function(d) {
            divTooltip.style( 'display', 'none' );
        });

        svg.append( 'g' )
           .attr( 'class', 'legendLinear' )
           .attr( 'transform', 'translate(100,' + (height + 30) +' )' );

        var legend  = d3.legend.color()
                               .shapeWidth(height/4)
                               .shapePadding(10)
                               .orient( 'horizontal' )
                               .scale(color);
        svg.select( '.legendLinear' ).call(legend);

        svg.append( 'text' )
           .attr( 'class', 'title' )
           .attr( 'x', (width/2) )
           .attr( 'y', 0)
           .attr( 'text-anchor', 'middle' )
           .style( 'font-size', '16px' )
           .text( 'Alert Status Breakout' );
    });
</script>
</body>
