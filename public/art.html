
<!DOCTYPE html>
<meta charset='utf-8'>
<style>
    body {
        font: 10px sans-serif;
    }

    .axis path,
    .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }

    .bar {
        fill: steelblue;
    }
</style>
<body>
    <script src='//d3js.org/d3.v4.min.js'></script>
    <script>
		const getTextWidth = (text, fontSize, fontName) => {
            c = document.createElement( 'canvas' );
            ctx = c.getContext( '2d' );
            ctx.font = fontSize + ' ' + fontName;
            return ctx.measureText(text).width;
        }

		const formatTickTime = d => { 
			let	days = Math.floor( d / ( 3600 * 24 ) ),
				hours = Math.floor( d / 3600 ),
				minutes = Math.floor( d / 60 ),
				seconds = d;
			if ( days ) {
				return days +'d';
			}
			if ( hours ) {
				return hours +'h';
			}
			if ( minutes ) {
				return minutes +'m';
			}
			return seconds +'s';
		};

		const logFormat = formatter => d => {
			var x = Math.log( d ) / Math.log(10) + 1e-6;
			return Math.abs( x - Math.floor( x ) ) < .5 ? formatter( d ) : '';
		}

        let margin = { top: 20, right: 20, bottom: 60, left: 50 },
            width = 1000 - margin.left - margin.right,
            height = 500 - margin.top - margin.bottom,
			barColors = {
				'All': '#98abc5',
				'Promoted': '#8a89a6',
				'Incident': '#7b6888',
			},
			lineColors = {
				'All Avg': 'gray',
				'Promoted Avg': 'blue',
				'Incident Avg': 'red',
			};

        let textWidthHolder = 0;

        var svg = d3.select( 'body' ).append( 'svg' )
					.attr( 'viewBox', '0 0 1000 500' )
                    .append( 'g' )
                    .attr( 'transform', 'translate( ' + margin.left + ',' + margin.top + ' )' );

        let url = '/scot/api/v2/metric/response_avg_last_x_days';
        let opts = '?days=7&targetdate=2017-07-21';
		d3.json(url+opts, data => {
			console.log( data );

			// Bar names
			let barNames = new Set();
			data.dates.forEach( d => {
				d.values.forEach( b => {
					barNames.add( b.name );
				} );
			} );

			// Line names
			let lineNames = new Set();
			data.lines.forEach( d => {
				lineNames.add( d.name );
			} );

			// Scales
			let maxValue = Math.max(
				d3.max( data.lines, d => d.value ),
				d3.max( data.dates, d => {
					return d3.max( d.values, b => b.value );
				} )
			);

			let dateScale = d3.scaleBand()
				.padding( 0.1 )
				.rangeRound( [ 0, width ] )
				.domain( data.dates.map( d => d.date ) );
			let barScale = d3.scaleBand()
				.domain( Array.from( barNames ) )
				.rangeRound( [ 0, dateScale.bandwidth() ] );
			let yScale = d3.scaleLog()
				.clamp( true )
				.base( 10 )
				.range( [ height, 0 ] )
				.domain( [ 1, maxValue ] )
				.nice();

			// Axes
			var xAxis = d3.axisBottom()
				.scale( dateScale );

			var yAxis = d3.axisLeft()
				.scale( yScale )
				.ticks( 20 )
				.tickFormat( logFormat( formatTickTime ) );

			const avgLine = d3.line()
				.x( d => 0)
				.y( d => yScale( d.value ) );

			svg.append( 'g' )
				.attr( 'class', 'x axis' )
				.attr( 'transform', `translate( 0, ${height} )` )
				.call( xAxis );

			svg.append( 'g' )
				.attr( 'class', 'y axis' )
				.call( yAxis )
				.append( 'text' )
					.attr( 'transform', 'rotate(-90)' )
					.attr( 'x', 0 - height / 2 )
					.attr( 'y', 0 - margin.left )
					.attr( 'dy', '1em' )
					.style( 'text-anchor', 'middle' )
					.style( 'fill', 'black' )
					.text( 'Seconds to Respond' );


			/*
			// Artificially modify data
			data.dates = data.dates.map( d => {
				d.values = d.values.map( val => {
					if ( val.value === 0 ) {
						val.value = Math.random() * maxValue;
					}
					return val;
				} );
				return d;
			} );
			*/
			// Bars
			let dates = svg.selectAll( '.date' )
				.data( data.dates )
				.enter().append( 'g' )
					.attr( 'class', 'date' )
					.attr( 'transform', d => `translate( ${dateScale( d.date )}, 0 )` );

			dates.selectAll( '.bar' )
				.data( d => d.values )
				.enter().append( 'rect' )
					.attr( 'class', 'bar' )
					.attr( 'width', barScale.bandwidth() )
					.attr( 'x', d => barScale( d.name ) )
					.attr( 'y', d => yScale( d.value ) )
					.attr( 'height', d => height - yScale( d.value ) )
					.style( 'fill', d => barColors[ d.name ] );

			// Lines
			const dateDomain = dateScale.domain();
			const lineStart = dateScale( dateDomain[0] ), lineEnd = dateScale( dateDomain[ dateDomain.length - 1 ] ) + dateScale.bandwidth();
			svg.selectAll( '.line' )
				.data( data.lines )
				.enter().append( 'g' )
					.attr( 'class', 'line' )
					.append( 'line' )
						.attr( 'x1', lineStart ).attr( 'y1', d => yScale( d.value ) )
						.attr( 'x2', lineEnd ).attr( 'y2', d => yScale( d.value ) )
						.style( 'stroke-width', '1.5px' )
						.style( 'fill', 'none' )
						.style( 'stroke', d => lineColors[ d.name ] );

			// Legend
			const legendData = [
				...Array.from( barNames ).map( d => { return { name: d, type: 'bar' } } ),
				...Array.from( lineNames ).map( d => { return { name: d, type: 'line' } } ),
			];
			let widthSum = 0;
			const textWidths = legendData.map( d => {
				let value = widthSum;
				widthSum += getTextWidth( d.name, '10px', 'sans-serif' );
				return value;
			} );
			const legendHeight = 20, legendSpacing = 15, legendTextSpacing = 5, legendLineHeight = 5;

			let LegendHolder = svg.append( 'g' )
					.attr( 'class', 'legendHolder' );
			let legend = LegendHolder.selectAll( '.legend' )
				.data( legendData )
				.enter().append( 'g' )
					.attr( 'class', 'legend' )
					.attr( 'transform', `translate( 0, ${ height + margin.bottom/2 } )` )

			// Legend Boxes
			legend.append( 'rect' )
				.attr( 'width', legendHeight )
				.attr( 'x', ( d, i ) => ( i + 1 ) * legendSpacing + i * legendHeight + i * legendTextSpacing + textWidths[i] )
				.attr( 'y', d => d.type === 'bar' ? 0 : legendHeight / 2 - legendLineHeight / 2 )
				.attr( 'height', d => d.type === 'bar' ? legendHeight : legendLineHeight )
				.style( 'fill', d => d.type === 'bar' ? barColors[ d.name ] : lineColors[ d.name ] );

			// Legend Text
			legend.append( 'text' )
				.attr( 'x', ( d, i ) => ( i + 1 ) * legendSpacing + ( i + 1 ) * legendHeight + ( i + 1 ) * legendTextSpacing + textWidths[i] )
				.attr( 'y', legendHeight / 2 )
				.attr( 'dy', '.35em' )
				.style( 'text-anchor', 'start' )
				.text( d => d.name );

			// Legend Position
			let legendWidth = LegendHolder.node().getBBox().width;
			LegendHolder.attr( 'transform', `translate( ${width / 2 - legendWidth / 2}, 0 )` );
    });

    </script>
</body>
