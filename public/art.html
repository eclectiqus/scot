
<!DOCTYPE html>
<meta charset='utf-8'>
<style>
    body {
        font: 10px sans-serif;
    }

    .axis path,
    .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }

    .bar {
        fill: steelblue;
    }

    .x.axis path {
        display: none;
    }
</style>
<body>
    <script src='//d3js.org/d3.v4.min.js'></script>
    <script>
		const getTextWidth = (text, fontSize, fontName) => {
            c = document.createElement( 'canvas' );
            ctx = c.getContext( '2d' );
            ctx.font = fontSize + ' ' + fontName;
            return ctx.measureText(text).width;
        }

		const formatMinutes = d => { 
			var hours = Math.floor( d / 3600 ),
				minutes = Math.floor( ( d - ( hours * 3600 ) ) / 60 ),
				seconds = d - ( hours * 3600 ) - ( minutes * 60 );
			if ( hours ) {
				return hours +'h';
			}
			if ( minutes ) {
				return minutes +'m';
			}
			return seconds +'s';
		};

		const logFormat = formatter => d => {
			var x = Math.log( d ) / Math.log(10) + 1e-6;
			return Math.abs( x - Math.floor( x ) ) < .5 ? formatter( d ) : '';
		}

        let margin = { top: 20, right: 40, bottom: 60, left: 40 },
            width = 1000 - margin.left - margin.right,
            height = 500 - margin.top - margin.bottom,
			barColors = {
				'All': '#98abc5',
				'Promoted': '#8a89a6',
				'Incident': '#7b6888',
			},
			lineColors = {
				'All Avg': 'gray',
				'Promoted Avg': 'blue',
				'Incident Avg': 'red',
			};

        let textWidthHolder = 0;

        var svg = d3.select( 'body' ).append( 'svg' )
					.attr( 'viewBox', '0 0 1000 500' )
                    .append( 'g' )
                    .attr( 'transform', 'translate( ' + margin.left + ',' + margin.top + ' )' );

        let url = '/scot/api/v2/metric/response_avg_last_x_days';
        let opts = '?days=7&targetdate=2017-07-21';
		d3.json(url+opts, data => {
			console.log( data );

			// Bar names
			let barNames = new Set();
			data.dates.forEach( d => {
				d.values.forEach( b => {
					barNames.add( b.name );
				} );
			} );

			// Line names
			let lineNames = new Set();
			data.lines.forEach( d => {
				lineNames.add( d.name );
			} );

			// Scales
			let maxValue = Math.max(
				d3.max( data.lines, d => d.value ),
				d3.max( data.dates, d => {
					return d3.max( d.values, b => b.value );
				} )
			);

			let dateScale = d3.scaleBand()
				.range( [ 0, width ] )
				.domain( data.dates.map( d => d.date ) );
			let barScale = d3.scaleBand()
				.domain( Array.from( barNames ) )
				.range( [ 0, dateScale.bandwidth() ] );
			let yScale = d3.scaleLog()
				.clamp( true )
				.base( 4 )
				.range( [ height, 0 ] )
				.domain( d3.range( 1, maxValue ) )
				.nice();

			// Axes
			var xAxis = d3.axisBottom()
				.scale( dateScale );

			var yAxis = d3.axisLeft()
				.scale( yScale )
				.tickFormat( logFormat( formatMinutes ) );

			svg.append( 'g' )
				.attr( 'class', 'x axis' )
				.attr( 'transform', `translate( 0, ${height} )` )
				.call( xAxis );

			svg.append( 'g' )
				.attr( 'class', 'y axis' )
				.call( yAxis )
				.append( 'text' )
					.attr( 'transform', 'rotate(-90)' )
					.attr( 'y', 6)
					.attr( 'dy', '.71em' )
					.style( 'text-anchor', 'end' )
					.style( 'fill', 'black' )
					.text( 'Seconds to Respond' );

			// Drawing Bars
			let state = svg.selectAll( '.state' )
				.data( data.dates )
				.enter().append( 'g' )
					.attr( 'class', 'state' )
					.attr( 'transform', d => `translate( ${dateScale( d.date )}, 0 )` );

			state.selectAll( 'rect' )
				.data( d => d.values )
				.enter().append( 'rect' )
					.attr( 'width', barScale.bandwidth() )
					.attr( 'x', d => barScale( d.name ) )
					.attr( 'y', d => yScale( d.value ) )
					.attr( 'height', d => height - yScale( d.value ) )
					.style( 'fill', d => barColors[ d.name ] );

			/*
        // drawaing lines
        svg.selectAll( '.lines' ).data(lineData).enter().append( 'g' ).attr( 'class', 'line' )
        .each(function (d) {
            Name=d[0].Name;
			d3.select(this)
				.append( 'path' )
				.attr( 'd', function (b) { return line(b) })
				.style( 'stroke-width', '2px' )
				.style( 'fill', 'none' )
				.style( 'stroke', LineColor(Name)).transition().duration(1500);
        })
		*/


        // Legends

        var LegendHolder = svg.append( 'g' ).attr( 'class', 'legendHolder' );
        var legend = LegendHolder.selectAll( '.legend' )
            .data(Categories.map(function (d) { return {'Name':d.Name,'Type':d.Type}}))
          .enter().append( 'g' )
            .attr( 'class', 'legend' )
            .attr( 'transform', function (d, i) { return 'translate(0,' +( height+ margin.bottom/2 )+ ' )'; })
            .each(function (d,i) {
                //  Legend Symbols


                d3.select(this).append( 'rect' )
                .attr( 'width', function () { return 18 })
                .attr( 'x', function (b) {

                    left = (i+1) * 15 + i * 18 + i * 5 + textWidthHolder;
                    return left;
                })
                 .attr( 'y', function (b) { return b.Type == 'bar'?0:7})
                .attr( 'height', function (b) { return b.Type== 'bar'? 18:5 })
                .style( 'fill', function (b) { return b.Type == 'bar' ? color(d.Name) : LineColor(d.Name) });

                //  Legend Text

                d3.select(this).append( 'text' )
                .attr( 'x', function (b) {

                    left = (i+1) * 15 + (i+1) * 18 + (i + 1) * 5 + textWidthHolder;

                    return left;
                })
                .attr( 'y', 9)
                .attr( 'dy', '.35em' )
                .style( 'text-anchor', 'start' )
                .text(d.Name);

                textWidthHolder += getTextWidth(d.Name, '10px', 'calibri' );
            });


        // Legend Placing

        d3.select( '.legendHolder' ).attr( 'transform', function (d) {
            thisWidth = d3.select(this).node().getBBox().width;
            return 'translate( ' + ((width) / 2 - thisWidth / 2) + ',0)';
        })
    });

    </script>
</body>
