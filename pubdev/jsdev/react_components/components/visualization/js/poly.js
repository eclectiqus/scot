// Generated by CoffeeScript 1.11.1
(function() {
  var BoundingBox, Poly, Polygon, Result, Utils, Vec, Voronoi, fgt, polygon, ref,
    hasProp = {}.hasOwnProperty;

  Result = require('./result').Result;

  ref = require('./geometry/polygon'), polygon = ref.polygon, Polygon = ref.Polygon;

  Utils = require('./utils');

  Vec = require('./geometry/vec');

  BoundingBox = require('./geometry/boundingbox');

  Voronoi = require('./geometry/voronoi');

  fgt = require('./geometry/eps').fgt;

  Poly = {
    drawPolygons: function(pgons, svg, w, h) {
      var container;
      container = svg.selectAll("g").data(pgons).enter().append("g").attr("transform", "translate(" + (w * 0.1) + ',' + (h * 0.1) + ')');
      container.append("polygon").attr("points", function(pgon) {
        return (pgon.verts.map(function(pt) {
          return pt.x() + ',' + pt.y();
        })).join(' ');
      }).attr("fill", function(pgon, n) {
        if ('color' in pgon) {
          return pgon.color;
        } else {
          return Utils.pickColor(n, pgons.length + 1);
        }
      }).attr("stroke-width", "1").attr("stroke", function(pgon) {
        return "black";
      });
      return container.append("text").attr("transform", function(pgon) {
        var cm;
        cm = pgon.center();
        return "translate(" + cm.x() + ',' + cm.y() + ')';
      }).text(function(d) {
        if (d.label) {
          return JSON.stringify(d.label);
        } else {
          return "";
        }
      }).attr("y", "0.35em").style("text-anchor", "middle");
    },
    drawImage: function(img, svg, w, h) {},
    grid: function(data) {
      var cellAt, cellh, cells, cellw, col, cols, h, padding, ref1, row, rows, w, x, y;
      rows = (Object.keys(data)).length;
      cols = Math.max.apply({}, (function() {
        var results;
        results = [];
        for (x in data) {
          if (!hasProp.call(data, x)) continue;
          results.push((Object.keys(data[x])).length);
        }
        return results;
      })());
      w = (document.getElementById("revl-vizbox")).offsetWidth * 0.8;
      h = (document.getElementById("revl-vizbox")).offsetHeight * 0.8;
      padding = 2;
      if ((w / cols < 10) || (h / rows < 10)) {
        padding = 0;
      }
      cellw = (w / cols) - padding;
      cellh = (h / rows) - padding;
      cellAt = function(x, y, data) {
        var p;
        p = polygon([[x, y + cellh], [x, y], [x + cellw, y], [x + cellw, y + cellh]]);
        p.input = data;
        return p;
      };
      cells = [];
      y = 0;
      for (row in data) {
        if (!hasProp.call(data, row)) continue;
        x = 0;
        ref1 = data[row];
        for (col in ref1) {
          if (!hasProp.call(ref1, col)) continue;
          cells.push(cellAt(x * (cellw + padding), y * (cellh + padding), data[row][col]));
          x++;
        }
        y++;
      }
      return {
        data: data,
        polygons: cells
      };
    },
    eachpoly: function(data, proc) {
      var k, len, poly, ref1;
      ref1 = data.polygons;
      for (k = 0, len = ref1.length; k < len; k++) {
        poly = ref1[k];
        proc(poly);
      }
      return data;
    },
    mappoly: function(data, proc) {
      var k, len, p, poly, r, ref1;
      r = [];
      ref1 = data.polygons;
      for (k = 0, len = ref1.length; k < len; k++) {
        poly = ref1[k];
        p = proc(poly);
        if ((typeof p) !== 'undefined') {
          if (Utils.isArray(p)) {
            r.push.apply(r, p);
          } else {
            r.push(p);
          }
        }
      }
      data.polygons = r;
      return data;
    },
    genpoints: function(count, boundary) {
      var bbox, i, j, k, mkpt, points, pt, ref1, v;
      bbox = boundary.bbox();
      points = [];
      pt = void 0;
      mkpt = function() {
        return new Vec([Math.random() * bbox.w + bbox.left(), Math.random() * bbox.h + bbox.top()]);
      };
      for (i = k = 0, ref1 = count; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
        pt = mkpt();
        j = 0;
        while (j < 10 && !boundary.contains(pt)) {
          j++;
          pt = mkpt();
        }
        if (j >= 10) {
          console.log("polygon(" + (JSON.stringify((function() {
            var l, len, ref2, results;
            ref2 = boundary.verts;
            results = [];
            for (l = 0, len = ref2.length; l < len; l++) {
              v = ref2[l];
              results.push([v.x(), v.y()]);
            }
            return results;
          })())) + ")");
          throw "Error: Couldn't make a point fit in the boundary for polygon " + (JSON.stringify(boundary));
        }
        points.push(pt);
      }
      return points;
    },
    voronoi: function(data, bbox, boundary) {
      var bound, i, k, polys, pts, ref1;
      if (boundary == null) {
        boundary = void 0;
      }
      bound = boundary || bbox;
      pts = Poly.genpoints(data.length, bound);
      polys = (new Voronoi(pts, bound)).layout().drawable();
      polys.input = data;
      for (i = k = 0, ref1 = data.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
        polys.polygons[i].input = data[i];
      }
      return polys;
    },
    commands: {
      help__draw: function() {
        return "draw\n\nDraw a graphic object. This command is designed to take\nthe output from numerous other commands such as grid,\nvoronoi, treemap, and others, and render them on\nscreen. You can also hand-code your own graphics objects\nif you're up for some pain.\n\nGraphic objects are simple objects with up to two\nfields: 'image' and 'polygons'\n\n'image' is something that can be interpreted as an image\n(either a URL or an array with bitmap values)\n\n'polygons' is a list of polygons. They must be in the\nformat accepted by PolyBoolJS, which is a structure with\ntwo fields, one named 'regions' and the other named\n'inverted'.\n\nThe 'regions' field should be a list of lists of\ntwo-element lists, where the innermost lists represent\nvertices of a polygon. Be careful with the ordering of the\nvertices in this case. If you don't want funky\nself-intersecting polygons, the vertices need to follow an\norderly route around the perimeter. the 'inverted' field\nshould just be false (unless you want a polygon the size\nof the universe with a hole in it specified by the\nvertices).\n\nGraphics objects also have a few other fields you can\ntinker with:\n* color - specifies the color of the field\n* input - this is the data that should be associated with\n  the polygon\n* stroke - the width of the border in pixels, can be zero\n* textcolor - color of text...\n\nExample:\n    $ $ [1..10] \\ (n)->[1..10].map (i)->[i,n] \\ grid \\\n    ..  into (g)->g.polygons.forEach ((p)->p.color = Utils.pickColor p.input[0]*p.input[1], 100); g\\\n    ..  draw\n    {\n        polygons: [\n            {\n                color: '#99342e',\n                input: [1, 1],\n                inverted: false,\n                regions: [[[0, 30.240], [0, 0], [50.64, 0], [50.64, 30.240]]]\n            },\n            {\n                color: '#993a2e',\n                input: [1, 2],\n                inverted: false,\n                regions: [\n                    [[0, 62.480], [0, 32.24], [50.64, 32.24], [50.64, 62.480]]\n                    ]\n            },...\n    }\n    \nThat command makes a 10x10 list of lists, each of which\nhas its offset coordinates as the final level. It then\nuses the grid command to make a 2d array of rectangular\ncells, one for each set of offset coordinates. Finally, it\nalters the color so that it's determined by the magnitude\nof the product of the two coordinates. The result is\npassed to draw so that it shows up on screen.\n\nThis command passes the input data through to its output\nwithout modification";
      },
      draw: function(argv, data, ctx) {
        var e, height, margin, svg, width;
        try {
          svg = d3.select("#revl-vizbox").html("").append("svg").attr("class", "viz");
          margin = {
            top: 20,
            right: 20,
            bottom: 30,
            left: 40
          };
          width = +document.querySelector("#revl-vizbox").offsetWidth - margin.left - margin.right;
          height = +document.querySelector("#revl-vizbox").offsetHeight - margin.top - margin.bottom;
          if ('image' in data) {
            Poly.drawImage(element, svg, width, height);
          }
          if ('polygons' in data) {
            Poly.drawPolygons(data.polygons, svg, width, height);
          }
          return Result.wrap(data);
        } catch (error) {
          e = error;
          return Result.err("polydraw: " + e);
        }
      },
      help__grid: function() {
        return "grid\n\nThis command takes a list of lists of data items, and\ncreates a graphic item containing an array of rectangular\ncells, one for each data item. The array mimics the\nstructure of the list, so if you have a 10x4 list, you'll\nhave 10 cells per row and 4 rows in the output graphic.\n\nThe 'input' field of each cell will hold its corresponding\ndata item so that further calculations can be done to\nalter things like color and whatnot. See the example for\nthe 'draw' command for an example of using this command\n(it's a long example).";
      },
      grid: function(argv, data, ctx) {
        var e;
        try {
          return Result.wrap(Poly.grid(data));
        } catch (error) {
          e = error;
          return Result.err("grid: " + e);
        }
      },
      help__eachpoly: function() {
        return "eachpoly &lt;func(poly,data,global_data)&gt;\n\neachpoly takes a function and calls it on every polygon in\na graphics object. The function is given the polygon\nitself, the cell's input data, and the original data (if\nany) that was used to create the whole graphics object.\n\nExample:\n    $ [1..10] \\ (n)->[1..10].map (i)->[i,n] \\ grid \\\n    ..  eachpoly (p)->p.color = Utils.heatColor p.input[0]*p.input[1],100 \\ draw\n\nThe example creates a heatmap with 100 cells, where the\nheat value is computed by multipling the row and column of\nthe cell in question ";
      },
      eachpoly: function(argv, data, ctx) {
        var e;
        try {
          return Utils.parsefunction(argv.join(' '), ctx).map(function(proc) {
            return Result.wrap(Poly.eachpoly(data, proc));
          });
        } catch (error) {
          e = error;
          return Result.err("eachpoly: " + e);
        }
      },
      help__mappoly: function() {
        return "mappoly <(poly)->newpoly>\n\nmappoly applies a function to each polygon in a drawable,\ngenerating a new drawable that replaces the original\npolygons with the result of calling the function on them.";
      },
      mappoly: function(argv, data, ctx) {
        var e;
        try {
          return Utils.parsefunction(argv.join(' '), ctx).map(function(proc) {
            return Result.wrap(Poly.mappoly(data, proc));
          });
        } catch (error) {
          e = error;
          return Result.err("mappoly: " + e);
        }
      },
      help__voronoi: function() {
        return "voronoi\n\nCreate a voronoi diagram to display data from the\npipeline. Voronoi diagrams are 2d space-filling diagrams\nthat allocate polygonal cells to each data element. This\ntool expects a list of items from the pipeline, and will\ncreate a diagram with a cell for each item. The result is\na drawable object that can be piped directly to the draw\ncommand, or can be further processed to give custom colors\nor make recursive treemaps.\n\nExample:\n    $ [1..100] \\ voronoi \\ draw\n\nThis makes a voronoi diagram with 100 cells and draws it\nusing the default color scheme and rectangular border.";
      },
      voronoi: function(argv, data, ctx) {
        var bbox, e, h, target, w;
        try {
          target = document.getElementById("revl-vizbox");
          w = target.offsetWidth * 0.8;
          h = target.offsetHeight * 0.8;
          bbox = new BoundingBox(0, 0, w, h);
          return Result.wrap(Poly.voronoi(data, bbox));
        } catch (error) {
          e = error;
          return Result.err("voronoi: " + e);
        }
      },
      help__voronoitree: function() {
        return "            ";
      },
      voronoitree: function(argv, data, ctx) {}
    }
  };

  module.exports = Poly;

}).call(this);

//# sourceMappingURL=poly.js.map
