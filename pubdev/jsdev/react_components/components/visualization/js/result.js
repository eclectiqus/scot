// Generated by CoffeeScript 1.11.1
(function() {
  var Error, Ok, Result, ResultPromise, Revl, Utils, err, unwrap, wrap,
    hasProp = {}.hasOwnProperty;

  Utils = require('./utils');

  Revl = require('./revl');

  err = function(x) {
    return new Result.Error(x);
  };

  wrap = function(x) {
    return new Result.Ok(x);
  };

  unwrap = function(x) {
    return x.content;
  };

  Result = {
    err: err,
    wrap: wrap,
    unwrap: unwrap,
    Ok: Ok = (function() {
      function Ok(content1) {
        this.content = content1;
      }

      Ok.prototype.map = function(fn) {
        return fn(this.content);
      };

      Ok.prototype.and_then = function(fn) {
        return wrap(fn(this.content));
      };

      Ok.prototype.map_err = function() {
        return this;
      };

      Ok.prototype.is_ok = function() {
        return true;
      };

      Ok.prototype.is_err = function() {
        return false;
      };

      return Ok;

    })(),
    Error: Error = (function() {
      function Error(content1) {
        this.content = content1;
      }

      Error.prototype.map = function() {
        return this;
      };

      Error.prototype.and_then = function() {
        return this;
      };

      Error.prototype.map_err = function(fn) {
        return fn(this.content);
      };

      Error.prototype.is_ok = function() {
        return false;
      };

      Error.prototype.is_err = function() {
        return true;
      };

      return Error;

    })()
  };

  ResultPromise = ResultPromise = (function() {
    function ResultPromise() {
      this.complete = false;
      this.error = false;
      this.content = void 0;
      this.next = void 0;
      this.success = this.__defaultsuccess;
      this.failure = this.__defaultfailure;
    }

    ResultPromise.prototype.fulfill = function(content) {
      if (this.complete || this.error) {
        return;
      }
      this.complete = true;
      this.content = content;
      this.success(content);
      return this.onProgress(1, 1);
    };

    ResultPromise.prototype.fail = function(content) {
      if (this.complete || this.error) {
        return;
      }
      this.error = true;
      this.content = content;
      return this.failure(content);
    };

    ResultPromise.prototype.progress = function(handler) {
      this.progressHandler = handler;
      this.onProgress(0, 1);
      return this;
    };

    ResultPromise.prototype.__defaultsuccess = function(content) {
      var ref;
      return (ref = this.next) != null ? ref.fulfill(content) : void 0;
    };

    ResultPromise.prototype.__defaultfailure = function(content) {
      var ref;
      return (ref = this.next) != null ? ref.fail(content) : void 0;
    };

    ResultPromise.prototype.onProgress = function(done, total) {
      var ref;
      if (typeof this.progressHandler === "function") {
        this.progressHandler(done, total);
      }
      return (ref = this.next) != null ? ref.onProgress(done, total) : void 0;
    };

    ResultPromise.prototype.map = function(fn) {
      this.next = new ResultPromise;
      this.success = (function(_this) {
        return function(result) {
          return _this.next.fulfill(fn(result));
        };
      })(this);
      if (this.complete) {
        this.success(this.content);
      }
      return this.next;
    };

    ResultPromise.prototype.map_err = function(fn) {
      this.next = new ResultPromise;
      this.failure = function(result) {
        return this.next.fail(fn(result));
      };
      if (this.error) {
        this.failure(this.content);
      }
      return this.next;
    };

    ResultPromise.wait = function(p, timeout) {
      if (timeout == null) {
        timeout = 60;
      }
      Utils = require('./utils');
      if (p instanceof ResultPromise) {
        return p;
      } else {
        return ResultPromise.waitreplace(p, timeout);
      }
    };

    ResultPromise.waitall = function(ps, timeout) {
      var count, i, j, n, p, ref, resetTimeout, result, timer, update, updatemaker, values;
      result = new ResultPromise;
      values = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = ps.length; j < len; j++) {
          p = ps[j];
          results.push(null);
        }
        return results;
      })();
      count = ps.length;
      timer = void 0;
      resetTimeout = function() {
        clearTimeout(timer);
        return timer = setTimeout((function() {
          console.log("Fulfilling promise with partial result. Last result was more than 10 seconds ago.");
          return result.fulfill(values.filter(function(v) {
            return v !== null;
          }));
        }), timeout * 1000);
      };
      update = function(d, n) {
        console.log("Assign promised result number " + n);
        values[n] = d;
        count--;
        if (count === 0) {
          clearTimeout(timer);
          return result.fulfill(values);
        }
      };
      updatemaker = function(n) {
        return function(d) {
          update(d, n);
          return resetTimeout();
        };
      };
      for (i = j = 0, ref = ps.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        n = i + 0;
        ps[i].map(updatemaker(n));
      }
      return result;
    };

    ResultPromise.waitreplace = function(mixed, timeout) {
      var holes, replacer, resetTimeout, result, timer, totalholes, update, updatemaker;
      result = new ResultPromise;
      totalholes = 0;
      holes = 0;
      timer = void 0;
      resetTimeout = function() {
        clearTimeout(timer);
        return timer = setTimeout((function() {
          console.log("Promise timed out, making partial fulfillment");
          return result.fulfill(mixed);
        }), timeout * 1000);
      };
      update = function(object, key, value, hole) {
        console.log("filled hole " + hole + ", " + holes + " remaining");
        object[key] = value;
        holes--;
        result.onProgress(totalholes - holes, totalholes);
        if (holes === 0) {
          clearTimeout(timer);
          result.fulfill(mixed);
          return console.log("Revl: ", Revl);
        }
      };
      updatemaker = function(object, key, hole) {
        return function(val) {
          update(object, key, val, hole);
          return resetTimeout();
        };
      };
      replacer = function(subitem) {
        var part, promise, results;
        results = [];
        for (part in subitem) {
          if (!hasProp.call(subitem, part)) continue;
          promise = subitem[part];
          if (promise instanceof ResultPromise) {
            promise.map(updatemaker(subitem, part, holes++));
            results.push(totalholes++);
          } else if ((Utils.isArray(promise)) || (Utils.isObject(promise))) {
            results.push(replacer(promise));
          } else {
            results.push(void 0);
          }
        }
        return results;
      };
      replacer(mixed);
      if (holes === 0) {
        result.fulfill(mixed);
      }
      return result;
    };

    ResultPromise.commands = {
      help__wait: function() {
        return "wait [timeout]\n\nIf you have run a command that will return a set of\npromises, this command will wait until all of them have\nbeen fulfilled, then continue the command pipeline with a\nlist of the resulting values.\n\nTimeout is an optional number of seconds to wait before\nreturning an incomplete result. The timer will be reset to\nthe full timeout after each successful completion, so\nthink of this as saying \"Wait as long as it takes while\nstuff is happening, but when there has been a long lag\nbetween updates, go ahead and just call it done.\" Note\nthat this result will have unfulfilled promise instances\nsprinkled through it, so you will have to filter them out\nif later pipeline elements can't deal with them.\n\nExample:\n    $ get \"https://a.com/event_ids\" \\ (id)->Http.asyncjson \"GET\",(\"https://a.com/event/\"+id) \\ wait\n    [list of events]\n\nHttp.asyncjson returns a promise that will be fulfilled\nwhen the server responds to the query. This command will\nwait on one promise or a list of promises, and fulfill its\nown promise when they are all completed.";
      },
      wait: function(argv, data, ctx) {
        if (argv.length > 0) {
          return Utils.parsevalue(argv.join(' '), ctx).map_err(function(e) {
            return Result.err('ResultPromise: ' + e);
          }).map(function(timeout) {
            return ResultPromise.wait(data, timeout);
          });
        } else {
          return ResultPromise.wait(data);
        }
      }
    };

    return ResultPromise;

  })();

  module.exports = {
    Result: Result,
    ResultPromise: ResultPromise
  };

}).call(this);

//# sourceMappingURL=result.js.map
