// Generated by CoffeeScript 1.11.1
(function() {
  var Nspace, Vec, feq, fgt, fgte, fle, fzero, ref;

  Vec = require('../geometry/vec');

  ref = require('../geometry/eps'), feq = ref.feq, fzero = ref.fzero, fgt = ref.fgt, fgte = ref.fgte, fle = ref.fle;

  Nspace = (function() {
    var Node;

    Nspace.MaxLoad = 5;

    Nspace.Node = Node = (function() {
      function Node(bounds) {
        this.bounds = bounds.slice(0);
        this.items = [];
        this.childpaths = {};
        this.childlist = [];
      }

      Node.prototype.insert = function(item, vec) {
        if (!this.contains(vec)) {
          return;
        }
        if (this.children().length !== 0) {
          return (this.getChildFor(vec)).insert(item, vec);
        } else {
          this.items.push([item, vec]);
          if (this.items.length >= Nspace.MaxLoad) {
            return this.split();
          }
        }
      };

      Node.prototype.split = function() {
        var coords, item, j, len, ref1, ref2;
        ref1 = this.items;
        for (j = 0, len = ref1.length; j < len; j++) {
          ref2 = ref1[j], item = ref2[0], coords = ref2[1];
          (this.getChildFor(coords)).insert(item, coords);
        }
        return this.items = [];
      };

      Node.prototype.low = function(i) {
        return this.bounds[i][0];
      };

      Node.prototype.high = function(i) {
        return this.bounds[i][1];
      };

      Node.prototype.getChildFor = function(vec) {
        var i, j, newbound, ref1, ref2, section;
        section = this.childpaths;
        newbound = [];
        for (i = j = 0, ref1 = vec.dim(); 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
          if (((this.low(i)) <= (ref2 = vec.nth(i)) && ref2 < ((this.low(i)) + (this.high(i))) / 2)) {
            if (section.low == null) {
              section.low = {};
            }
            section = section.low;
            newbound.push([this.low(i), ((this.low(i)) + (this.high(i))) / 2]);
          } else {
            if (section.high == null) {
              section.high = {};
            }
            section = section.high;
            newbound.push([((this.low(i)) + (this.high(i))) / 2, this.high(i)]);
          }
        }
        if ((typeof section.node) === "undefined") {
          section.node = new Nspace.Node(newbound);
          this.childlist.push(section.node);
        }
        return section.node;
      };

      Node.prototype.contains = function(vec) {
        var i, j, ref1, ref2;
        for (i = j = 0, ref1 = vec.dim(); 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
          if (!(((this.low(i)) <= (ref2 = vec.nth(i)) && ref2 <= (this.high(i))))) {
            return false;
          }
        }
        return true;
      };

      Node.prototype.leaves = function() {
        var child;
        if (this.children().length !== 0) {
          return [].concat.apply([], (function() {
            var j, len, ref1, results;
            ref1 = this.children();
            results = [];
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              results.push(child.leaves());
            }
            return results;
          }).call(this));
        } else {
          return [this];
        }
      };

      Node.prototype.children = function() {
        return this.childlist;
      };

      return Node;

    })();

    function Nspace() {
      this.coord_index = {};
      this.lowbound = 0;
      this.highbound = 0;
      this.nextdim = 0;
      this.items = [];
    }

    Nspace.prototype.insert = function(item, coords) {
      var base, coord, j, len, name, results;
      this.items.push([item, coords]);
      results = [];
      for (j = 0, len = coords.length; j < len; j++) {
        coord = coords[j];
        if ((base = this.coord_index)[name = coord[0]] == null) {
          base[name] = this.nextdim++;
        }
        results.push(this.updatebounds(coord));
      }
      return results;
    };

    Nspace.prototype.updatebounds = function(coord) {
      var results;
      if (coord[1] < this.lowbound) {
        this.lowbound = coord[1];
      }
      if (coord[1] > this.highbound) {
        this.highbound = coord[1];
      }
      results = [];
      while (feq(this.lowbound, this.highbound)) {
        this.lowbound -= Math.random();
        results.push(this.highbound += Math.random());
      }
      return results;
    };

    Nspace.prototype.subdivide = function() {
      var b, bounds, coord, coords, i, item, j, k, len, len1, ref1, ref2;
      bounds = (function() {
        var j, ref1, results;
        results = [];
        for (i = j = 0, ref1 = this.nextdim; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
          results.push([this.lowbound, this.highbound]);
        }
        return results;
      }).call(this);
      this.root = new Nspace.Node(bounds);
      ref1 = this.items;
      for (j = 0, len = ref1.length; j < len; j++) {
        item = ref1[j];
        coords = (function() {
          var k, len1, results;
          results = [];
          for (k = 0, len1 = bounds.length; k < len1; k++) {
            b = bounds[k];
            results.push(0);
          }
          return results;
        })();
        ref2 = item[1];
        for (k = 0, len1 = ref2.length; k < len1; k++) {
          coord = ref2[k];
          coords[this.coord_index[coord[0]]] = coord[1];
        }
        this.root.insert(item, new Vec(coords));
      }
      this.items = void 0;
      return this;
    };

    Nspace.prototype.leaves = function() {
      return this.root.leaves();
    };

    Nspace.commands = {
      help__Nspace: function() {
        return "Nspace (class)\n\nNspace is a space partitioning tree that works in an\narbitrary number of dimensions. Its purpose is to make it\neasy to take vectors of high-dimensional data and find\nwhich ones are close together (i.e. spatial clustering),\nand to do other high-dimensional spatial calculations (find\nitems within a distance of some point, within a bounding\nbox, intersecting some polytope, etc).\n\nThe main mode of use is as an accumulator on the command\nline in the fold commands (foldl, foldr). It allows you to\nbuild up the high-dimensional space incrementally by just\ninserting data points. Each data point is represented as a\nlist of pairs, where the first element of the pair is the\n*name* of the coordinate (more on this later), and the\nsecond element is the value of the coordinate. For example,\nif you are just using the standard 3d coordinate system,\nyou could use something like this:\n\n    [item1, [[x,1],[y,33],[z,-10]]]\n\nThe power of this representation is that it allows you to\nuse an arbitrary naming scheme for your coordinates. Let's\nsay you want to cluster a large collection of messages\naccording to the domain names that are harvested from them\nas flair in SCOT. You could just decide that each domain\nname will be a coordinate, and pass in points as the data\nelement followed by the list of domains it references, with\nones for the values:\n     \n    [msg1, [[\"foo.com\",1],[\"bar.com\",1],[\"baz.com\",1]]]\n    \nNot all messages will reference all domains (obviously),\nbut you don't have to try to precompute the full set of\ndomains because the Nspace will accumulate them for you. If\nyour message set references 100 domains in total, but any\ngiven message only references two or three, then the Nspace\nwill have 100 dimensions after the inserts are\ncomplete. Each coordinate that is not defined for an\ninserted item is set to zero automatically.\n\nThe downside of this incremental load process is that you\nhave to wait until all of your inserts are done, then call\nthe 'subdivide' function in order to actually build the\ndata structure. In practice, this adds one more element to\nthe pipeline in your command.\n\nHere is a command you can try that uses Nspace to draw a\nquadtree based on random data:\n\n    [1..100] \\\n    foldl new Nspace (s,pt) -> s.insert pt,[['x',Math.random()],['y',Math.random()]]; s  \\\n    (s)->s.subdivide() \\\n    (sp)->sp.leaves() \\\n    (l)->l.bounds \\\n    (bnd)->List.zip bnd \\\n    (pts)->[[pts[0][0],pts[0][1]],[pts[0][0],pts[1][1]],[pts[1][0],pts[1][1]],[pts[1][0],pts[0][1]]] \\\n    (pts)->(polygon pts).scale 200 \\\n    into (polys)->{polygons: polys} \\\n    draw\n\n This command starts by generating a list of length 100,\n then converts that into a list of 100 points. Each point\n has its index number for data, and randomly generated 'x'\n and 'y' coordinates.\n\n The points are inserted into an empty Nspace object using\n the foldl command.\n\n The resulting data structure is finalized using the ()->\n map construct to call subdivide()\n\n The leaf nodes are collected (these are the only nodes\n with actual data)\n\n The bounds of each leaf node are found (this gives a lower\n and upper bound on each coordinate dimension)\n\n The bounds lists are re-zipped so that they become a\n lower-left corner and upper right corner\n ([[x_low,x_high],[y_low,y_high]] => [[x_low,y_low],[x_high,y_high]])\n\n The remaining corners of a square are created by copying\n the appropriate parts of the lower-left and upper-right\n corners into a lower-right and upper-left.\n\n Polygons are created from those point lists, and scaled up\n by a factor of 200 to make them visible\n\n The list of polygons is converted into a drawable object\n (basically just put a list of polygons into an object\n under the name 'polygons')\n\n Finally, the whole mess is piped into the draw function,\n which puts a colorful rendering of the tree on screen.\n\n This object is designed to be used with dimensionality\n reduction code, see 'help pca' for more details.";
      }
    };

    return Nspace;

  })();

  module.exports = Nspace;

}).call(this);

//# sourceMappingURL=nspace.js.map
