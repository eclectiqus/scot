// Generated by CoffeeScript 1.11.1
(function() {
  var List, Utils,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  Utils = require('./utils');

  List = {
    map: function(list, proc) {
      return list.map(proc);
    },
    filter: function(list, proc) {
      return list.filter(proc);
    },
    foldl: function(acc, list, proc) {
      var item, j, len, n, result;
      result = acc;
      for (n = j = 0, len = list.length; j < len; n = ++j) {
        item = list[n];
        result = proc(result, item, n);
      }
      return result;
    },
    foldr: function(list, acc, proc) {
      var j, n, ref, result;
      result = acc;
      for (n = j = ref = list.length - 1; ref <= 0 ? j <= 0 : j >= 0; n = ref <= 0 ? ++j : --j) {
        result = proc(list[n], result, n);
      }
      return result;
    },
    group: function(list, sep) {
      return List.foldl({}, list, (function(groups, element) {
        var name;
        name = sep(element);
        if (groups[name] == null) {
          groups[name] = [];
        }
        groups[name].push(element);
        return groups;
      }));
    },
    deepmap: function(ls, proc) {
      var item, j, len, result;
      result = [];
      for (j = 0, len = ls.length; j < len; j++) {
        item = ls[j];
        if (Utils.isArray(item)) {
          result.push(List.deepmap(item, proc));
        } else {
          result.push(proc(item));
        }
      }
      return result;
    },
    mapall: function(ls, proc) {
      var i, j, ref, result;
      result = [];
      if ((ls.length < 1) || !(Utils.isArray(ls[0]))) {
        return result;
      }
      for (i = j = 0, ref = ls[0].length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        result.push(proc.apply(null, ls.map(function(l) {
          return l[i];
        })));
      }
      return result;
    },
    zip: function(ls) {
      return List.mapall(ls, function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return args;
      });
    },
    flatten: function(ls) {
      return List.foldl([], ls, function(acc, val) {
        return acc.concat(val);
      });
    },
    squash: function(ls) {
      var acc, squasher;
      acc = [];
      squasher = function(item) {
        var i, j, len, results;
        if (Utils.isArray(item)) {
          results = [];
          for (j = 0, len = item.length; j < len; j++) {
            i = item[j];
            results.push(squasher(i));
          }
          return results;
        } else {
          return acc.push(item);
        }
      };
      squasher(ls);
      return acc;
    },
    sort: function(ls, proc) {
      if (proc == null) {
        proc = Utils.smartcmp;
      }
      return ls.sort(proc);
    },
    uniq: function(ls, cmp) {
      if (cmp == null) {
        cmp = Utils.smartcmp;
      }
      return List.foldl([ls[0]], ls.slice(1), (function(r, item) {
        if (0 !== cmp(item, r[r.length - 1])) {
          r.push(item);
        }
        return r;
      }));
    },
    nest: function(ls, proc) {
      var current, entry, item, j, len, len1, m, n, name, nested, paths, ref;
      paths = (function() {
        var j, len, results;
        results = [];
        for (n = j = 0, len = ls.length; j < len; n = ++j) {
          item = ls[n];
          results.push({
            item: item,
            path: proc(item, n)
          });
        }
        return results;
      })();
      nested = {};
      for (j = 0, len = paths.length; j < len; j++) {
        entry = paths[j];
        current = nested;
        ref = entry.path;
        for (m = 0, len1 = ref.length; m < len1; m++) {
          name = ref[m];
          if (current[name] == null) {
            current[name] = {};
          }
          current = current[name];
        }
        if (current.$ == null) {
          current.$ = [];
        }
        current.$.push(entry.item);
      }
      return nested;
    },
    bfs: function(ls, proc) {
      var i, item, n, q, result;
      result = [];
      q = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = ls.length; j < len; j++) {
          i = ls[j];
          results.push(i);
        }
        return results;
      })();
      n = 0;
      while (q.length > 0) {
        item = q.shift();
        if (Utils.isArray(item)) {
          q.push.apply(q, item);
        } else {
          result.push(proc(item, n));
          n = n + 1;
        }
      }
      return result;
    },
    histogram: function(ls, proc) {
      var j, len, n, p;
      p = {};
      for (j = 0, len = ls.length; j < len; j++) {
        n = ls[j];
        if (p[n] == null) {
          p[n] = 0;
        }
        p[n]++;
      }
      return p;
    },
    tostruct: function(ls) {
      return List.foldl({}, ls, (function(acc, l) {
        acc[l[0]] = l[1];
        return acc;
      }));
    },
    cmb: function(ls, n) {
      var i, j, r, ref, result;
      console.log("cmb " + (JSON.stringify(ls)) + "," + n);
      result = [];
      if (n > ls.length) {
        throw "Can't take " + n + " from list of length " + ls.length;
      }
      if (n === 1) {
        r = ls.map(function(e) {
          return [e];
        });
        return r;
      }
      for (i = j = 0, ref = ls.length - n; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        r = List.cmb(ls.slice(i + 1), n - 1);
        r.forEach(function(l) {
          return l.unshift(ls[i]);
        });
        result = result.concat(r);
      }
      return result;
    },
    window: function(ls, n, proc) {
      var i, j, ref, results;
      if (ls.length < n) {
        throw "Window of " + n + " too large for list of " + ls.length + " elements";
      }
      results = [];
      for (i = j = 0, ref = ls.length - n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        results.push(proc.apply({}, ls.slice(i, i + n)));
      }
      return results;
    },
    intersect: function(ls, proc) {
      var g_index, group, index, j, k, key, len, len1, listcount, m, ref, ref1, set, value;
      if (proc == null) {
        proc = function(x) {
          return x;
        };
      }
      set = {};
      listcount = 0;
      for (g_index in ls) {
        if (!hasProp.call(ls, g_index)) continue;
        group = ls[g_index];
        listcount++;
        for (index in group) {
          if (!hasProp.call(group, index)) continue;
          value = group[index];
          key = proc(value, index);
          if (set[key] == null) {
            set[key] = {
              count: 0,
              items: []
            };
          }
          set[key].count++;
          set[key].items.push(value);
        }
      }
      ref = Object.keys(set);
      for (j = 0, len = ref.length; j < len; j++) {
        k = ref[j];
        if (set[k].count < listcount) {
          delete set[k];
        }
      }
      set;
      ref1 = Object.keys(set);
      for (m = 0, len1 = ref1.length; m < len1; m++) {
        k = ref1[m];
        if (set[k].count < listcount) {
          delete set[k];
        }
      }
      return set;
    },
    select: function(data, indexes) {
      var index, j, len, results;
      results = [];
      for (j = 0, len = indexes.length; j < len; j++) {
        index = indexes[j];
        if (index in data) {
          results.push(data[index]);
        }
      }
      return results;
    }
  };

  List.fold = List.foldr;

  List.unzip = List.zip;

  module.exports = List;

  if ((typeof window) === 'undefined') {
    console.log(List.cmb([1, 2, 3, 4], 2));
  }

}).call(this);

//# sourceMappingURL=list.js.map
