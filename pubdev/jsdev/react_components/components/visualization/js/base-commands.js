// Generated by CoffeeScript 1.11.1
(function() {
  var BaseCommands, List, Result, ResultPromise, Struct, Utils, ref,
    hasProp = {}.hasOwnProperty;

  Utils = require('./utils.js');

  List = require('./list.js');

  Struct = require('./struct.js');

  ref = require('./result.js'), Result = ref.Result, ResultPromise = ref.ResultPromise;

  BaseCommands = {
    help__into: function() {
      return "into &lt;function&gt;\n    \nTake the input and apply the function directly to it,\nregardless of its internal format. Normally, data is checked\nto see if it is list-like or not before deciding what the\nbehavior of map and fold, etc should be. In this case, you're\nsaying that you just want whatever the contents of the data is\nto be handed to you directly in one piece.\n\nExample:\n   $ [1,2,3] \\ into (f) -> 12\n   12\nWithout into:\n   $ [1,2,3] \\ (f)->12\n   [12,12,12]";
    },
    into: (function(_this) {
      return function(argv, d, ctx) {
        console.log("into(proc)");
        return Utils.parsefunction(argv.join(" "), ctx).map(function(proc) {
          var e;
          try {
            return Result.wrap(proc(d));
          } catch (error) {
            e = error;
            console.log("exception " + e);
            return Result.err('' + e);
          }
        }).map_err(function(e) {
          console.log("error");
          return Result.err("into(proc): " + e);
        });
      };
    })(this),
    help__map: function() {
      return "map &lt;function&gt;\n\nMap applies the given function to the data. If the data is an\narray (list), map will apply the function to each element of\nthe list and return a list containing the results. If the data\nis an object, proc will be called on each item in the struct\nwith the value and the key as args (yes, in that order - this\nway you can ignore the key most times, which is what you\nprobably want).\n\n\nExample:\n  $ [1,2,3,4] \\ map (n) -> n*2\n  [2,4,6,8]\n  $ {foo: 12} \\ map (v,k) -> v*9\n  {foo: 108}";
    },
    map: (function(_this) {
      return function(argv, ls, ctx) {
        console.log("map(proc)");
        return Utils.parsefunction(argv.join(" "), ctx).map(function(proc) {
          var e;
          try {
            if (Utils.isArray(ls)) {
              return Result.wrap(List.map(ls, proc));
            } else if (Utils.isObject(ls)) {
              return Result.wrap(Struct.map(ls, proc));
            }
          } catch (error) {
            e = error;
            return Result.err('' + e);
          }
        }).map_err(function(msg) {
          return Result.err("map(proc): " + msg);
        });
      };
    })(this),
    help__tolist: function() {
      return "tolist\n\nConvert a struct to a list. If argument is a list, it will be\nunchanged. The result is a list of pairs, where the first\nelement of each pair is the key for an item in the struct, and\nthe second element is the value associated with that key.\n\nExample:\n    $ {a: 1, b: 2} \\ tolist\n    [[a,1],[b,2]]";
    },
    tolist: (function(_this) {
      return function(argv, d, ctx) {
        return Result.wrap(Struct.tolist(d));
      };
    })(this),
    help__tostruct: function() {
      return "tostruct\n\nConvert a list of pairs into an object (struct) that has an\nentry for each pair in the list. The keys will be the first\nelements of each pair, and the values will be the second\nelements. In other words, create a struct from an association\nlist.\n\nExample:\n    $ [[1,'a'],['b',2]] \\ tostruct\n    {1: 'a', b: 2}";
    },
    tostruct: (function(_this) {
      return function(argv, d, ctx) {
        return Result.wrap(List.tostruct(d));
      };
    })(this),
    help__mapall: function() {
      return "mapall function\n    \nMapall works on a list of lists. It will proceed through all\nsublists in parallel, taking the next element of each sublist and\nproviding them in order as arguments to a single call of the\nfunction. The resulting value will be appended to the final\nresult, which will be a single list of the same length as one of\nthe sublists. This is hard to explain in words, so here are some\nexamples:\n    \n  $ [[1,2,3],[1,2,3],[1,2,3]] \\ mapall (a,b,c) -> [a,b,c]\n  [[1,1,1],[2,2,2],[3,3,3]]\n    \n  $ [[1,2,3],[1,2,3],[1,2,3]] \\ mapall (a,b,c) -> a+b+c\n  [3,6,9]\n    \n  $ [[1,2,3],[1,2,3],[1,2,3]] \\ mapall (args...) -> args\n  [[1,1,1],[2,2,2],[3,3,3]]";
    },
    mapall: (function(_this) {
      return function(argv, ls, ctx) {
        console.log("mapall");
        return Utils.parsefunction(argv.join(" "), ctx).map(function(proc) {
          var e;
          try {
            return Result.wrap(List.mapall(ls, proc));
          } catch (error) {
            e = error;
            return Result.err('' + e);
          }
        }).map_err(function(msg) {
          return Result.err("mapall(proc): " + msg);
        });
      };
    })(this),
    help__filter: function() {
      return "filter function\n\nFilter calls the given function on each element of the data\nlist and only adds the element to the output list if the\nresult is truthy (i.e. not false).\n\nExample:\n  $ [1,2,3] \\ filter (n) -> n>=2\n  [2,3]";
    },
    filter: (function(_this) {
      return function(argv, ls, ctx) {
        return Utils.parsefunction(argv.join(" "), ctx).map(function(proc) {
          if (Utils.isArray(ls)) {
            return Result.wrap(List.filter(ls, proc));
          } else if (Utils.isObject(ls)) {
            return Result.wrap(Struct.filter(ls, proc));
          } else {
            throw "Can't filter something that is neither object nor list";
          }
        }).map_err(function(msg) {
          return Result.err("filter: " + msg);
        });
      };
    })(this),
    help__foldl: function() {
      return "foldl &lt;initial_value&gt; &lt;function(accumulator,next_val)&gt;\n\nfoldl takes an initial value and a function, and repeatedly\ncalls the given function on two arguments: the value of an\naccumulator and the value of the next item in the input\nlist. This is done left-associatively (hence the 'l' in\n'foldl'), so that the first call to the function consumes the\ninitial value with the first list element, and it proceeds in\norder through the list from left to right. foldr is also\navailable, which works right-associatively. In this way you\ncan do things like add up all of the numbers in a list, or\nconcatenate all of the strings in a list, or turn a list of\npairs into an object with keys and values:\n\nExamples:\n  $ [1,2,3] \\ foldl 0 (acc,n) -> acc+n\n  6\n\n  $ ['a','b','c'] \\ foldl \"\" (acc,n) -> acc+n\n  'abc'\n\n  $ [['a', 1],['b',2],['c',3]] \\ foldl {} (acc,n) -> acc[n[0]] = n[1]; acc\n  {a: 1, b: 2, c: 3}\n\n  $ ['a','b','c'] \\ foldl 'x' (acc,n) -> '(' + acc + ',' + n + ')'\n  ((('x','a'),'b'),'c')\n\nNote in the object example that you have to explicitly return\nthe accumulator, otherwise you'll just get undefined (the\nmember assignment operator doesn't return anything in\ncoffeescript) ";
    },
    foldl: (function(_this) {
      return function(argv, ls, ctx) {
        var args, parts;
        console.log("foldl");
        args = argv.join(' ');
        parts = args.match(/^([^>]+)(\([a-zA-Z,]*\) *->.*)$/m);
        console.log("Parts: " + JSON.stringify(parts));
        return (!parts ? Result.err("expected an initial value and a function") : Utils.parsefunction(parts[2], ctx).map(function(proc) {
          return Utils.parsevalue(parts[1], ctx).map(function(acc) {
            var e;
            try {
              return Result.wrap(List.foldl(acc, ls, proc));
            } catch (error) {
              e = error;
              return Result.err('' + e);
            }
          });
        })).map_err(function(e) {
          return Result.err("foldl: " + e);
        });
      };
    })(this),
    help__foldr: function() {
      return "foldr &lt;initial_value&gt; &lt;function(next_val,accumulator)&gt;\n\nfoldr takes an initial value and a function, and repeatedly\ncalls the given function on two arguments: the value of an\naccumulator and the value of the next item in the input\nlist. This is done right-associatively (hence the 'r' in\n'foldr'), so that the first call to the function consumes the\ninitial value with the last list element, and it proceeds in\norder through the list from right to left. foldl is also\navailable, which works left-associatively. In this way you\ncan do things like add up all of the numbers in a list, or\nconcatenate all of the strings in a list, or turn a list of\npairs into an object with keys and values:\n\nExamples:\n  $ [1,2,3] \\ foldr 0 (n,acc) -> n+acc\n  6\n\n  $ ['a','b','c'] \\ foldr \"\" (n,acc) -> n+acc\n  'abc'\n\n  $ [['a', 1],['b',2],['c',3]] \\ foldr {} (n,acc) -> acc[n[0]] = n[1]; acc\n  {a: 1, b: 2, c: 3}\n\n  $ ['a','b','c'] \\ foldr 'x' (n,acc) -> '(' + n + ',' + acc + ')'\n  ('a',('b',('c','x')))\n\nNote in the object example that you have to explicitly return\nthe accumulator, otherwise you'll just get undefined (the\nmember assignment operator doesn't return anything in\ncoffeescript) ";
    },
    foldr: (function(_this) {
      return function(argv, ls, ctx) {
        var args, parts;
        console.log("foldr");
        args = argv.join(' ');
        parts = args.match(/^([^(]+)(\([^)]*\)\s*->.*)$/m);
        return (!parts ? Result.err("expected an initial value and a function") : Utils.parsefunction(parts[2], ctx).map(function(proc) {
          return Utils.parsevalue(parts[1], ctx).map(function(acc) {
            var e;
            try {
              return Result.wrap(List.foldr(ls, acc, proc));
            } catch (error) {
              e = error;
              return Result.err('' + e);
            }
          });
        })).map_err(function(e) {
          return Result.err("foldr: " + e);
        });
      };
    })(this),
    help__group: function() {
      return "group &lt;function(item)&gt;\n    \ngroup takes a list from the input and groups the items into fields\nof an object. The function argument should take an item from the\nlist and return the name of the group it belongs with. The value\nreturned will be an object with each item assigned to a list under\nthe appropriate name.\n    \nExamples:\n  $ [1,2,3] \\ group (n)-> if n < 3 then 'small' else 'large'\n  {small: [1,2], large: [3]}\n";
    },
    group: (function(_this) {
      return function(argv, d, ctx) {
        console.log("group");
        return Utils.parsefunction(argv.join(" "), ctx).map(function(proc) {
          var e;
          try {
            return Result.wrap(List.group(d, proc));
          } catch (error) {
            e = error;
            return Result.err('' + e);
          }
        }).map_err(function(e) {
          return Result.err("group: " + e);
        });
      };
    })(this),
    help__zip: function() {
      return "zip\n\nzip takes a list of lists and returns a new list of lists,\nwhere the sublists contain all of the elements that have the\nsame positions in the original sublists. In other words, the\nfirst returned sublist will have the first element from each\nof the input sublists, and the second result sublist will have\nthe second element from each input sublist, etc.\n\nExample:\n  $ [[1,2,3],['a','b','c']] \\ zip\n  [[1,'a'],[2,'b'],[3,'c']]";
    },
    zip: (function(_this) {
      return function(argv, ls, ctx) {
        var e;
        return ((function() {
          if (argv.length !== 0) {
            return Result.err("zip does not accept parameters");
          } else {
            try {
              return Result.wrap(List.zip(ls));
            } catch (error) {
              e = error;
              return Result.err('' + e);
            }
          }
        })()).map_err(function(msg) {
          return Result.err("zip: " + msg);
        });
      };
    })(this),
    help__unzip: function() {
      return "unzip\n\nunzip does exactly the same thing as zip. It's just an alias\nin case you forget that zip undoes itself by just calling it\nagain\n\nExample:\n  $ [[1,2,3],['a','b','c']] \\ zip\n  [[1,'a'],[2,'b'],[3,'c']]\n\n  $ [[1,'a'],[2,'b'],[3,'c']] \\ unzip\n  [[1,2,3],['a','b','c']]";
    },
    unzip: (function(_this) {
      return function(argv, ls, ctx) {
        var e;
        return ((function() {
          if (argv.length !== 0) {
            return Result.err("unzip does not accept parameters");
          } else {
            try {
              return Result.wrap(List.zip(ls));
            } catch (error) {
              e = error;
              return Result.err('' + e);
            }
          }
        })()).map_err(function(msg) {
          return Result.err("unzip: " + msg);
        });
      };
    })(this),
    help__flatten: function() {
      return "flatten\n\nflatten takes a list of lists and removes one layer of\nnesting. If your data looks like a list of flat lists, and you\nwant it to just be a single flat list, flatten will do\nthat. It ignores elements that aren't sublists, leaving them\nalone in the data, so you can use this to get rid of unwanted\nnesting with mixed data.\n\nExamples:\n  $ [[1,2,3],[4,5,6]] \\ flatten\n  [1,2,3,4,5,6]\n\n  $ [[[1,2],3], 4] \\ flatten\n  [[1,2],3,4] ";
    },
    flatten: (function(_this) {
      return function(argv, ls, ctx) {
        var e;
        return ((function() {
          if (argv.length !== 0) {
            return Result.err("flatten does not accept parameters");
          } else {
            try {
              return Result.wrap(List.flatten(ls));
            } catch (error) {
              e = error;
              return Result.err('' + e);
            }
          }
        })()).map_err(function(msg) {
          return Result.err("flatten: " + msg);
        });
      };
    })(this),
    help__squash: function() {
      return "squash\n\nsquash removes all levels of nesting from a nested list. No\nmatter how deeply the list is nested, the returned value will\nbe a flat list, which preserves the order of the elements as\nyou would expect.\n\nExample:\n  $ [[[[1],2],3],[[[4]]]] \\ squash\n  [1,2,3,4]";
    },
    squash: (function(_this) {
      return function(argv, ls, ctx) {
        var e;
        return ((function() {
          if (argv.length !== 0) {
            return Result.err("squash does not accept parameters");
          } else {
            try {
              return Result.wrap(List.squash(ls));
            } catch (error) {
              e = error;
              return Result.err('' + e);
            }
          }
        })()).map_err(function(msg) {
          return Result.err("squash: " + msg);
        });
      };
    })(this),
    help__sort: function() {
      return "sort [function(a,b)]\n\nsort the input list according to the given comparison\nfunction. The comparison function should return values as\nfollows:\n   if a before b then return -1\n   if a same as b then return 0\n   if a after b then return 1\n\nThe sort function is optional. If you use the default, it will\nsort numbers according to their value (NOT the javascript\ndefault of sorting them according to their alphabetical\norder), and it will sort strings alphabetically. In mixed\ndata, numbers are less than strings, and everything else is\nsorted using javascript's default comparison.\n\nExamples:\n  $ [3,31,5,22] \\ sort\n  [3,5,22,31]\n\n  $ [3,'a',{b:12},31,5,22] \\ sort\n  [3, 5, 22, 31, {b: 12}, 'a']";
    },
    sort: (function(_this) {
      return function(argv, ls, ctx) {
        var cmp;
        console.log("sort");
        cmp = Utils.smartcmp;
        return (argv.length > 0 ? Utils.parsefunction(argv.join(" "), ctx).map_err(function(e) {
          return Result.err("sort: expected a comparison function, or nothing");
        }).map(function(cmp) {
          var e;
          try {
            return Result.wrap(List.sort(ls, cmp));
          } catch (error) {
            e = error;
            return Result.err('' + e);
          }
        }) : Result.wrap(List.sort(ls, cmp))).map_err(function(e) {
          return Result.err("sort: " + e);
        });
      };
    })(this),
    help__uniq: function() {
      return "uniq [compare]\n\nuniq takes an optional comparison function and returns the\ninput list with all duplicate entries removed. This works like\nthe unix uniq command, which means you *have* to give it\nsorted data. You can use the same comparison function for uniq\nthat you use for sort (and the default function will work in\nalmost all cases, which means you can usually just skip this\nparameter entirely). If you need to wrote a comparison\nfunction, it should return zero if the two items are equal.\n\nUniq only compares adjacent items in the list. If your list is\nnot sorted so that the duplicate items are all next to each\nother, it will not work.\n\nExamples:\n    $ [1,2,2,3,3,3,4] \\ uniq\n    [1,2,3,4]\n\n    $ [1,2,1,2,1,2,1,2] \\ uniq\n    [1,2,1,2,1,2,1,2]\n\n    The first example shows how uniq dedups the list. The\n    second example shows that it doesn't work if your dups\n    aren't all adjacent to each other (which can be easily\n    achieved with the sort command, see 'help sort'). ";
    },
    uniq: function(argv, ls, ctx) {
      var cmp;
      cmp = Utils.smartcmp;
      return (argv.length > 0 ? Utils.parsefunction(argv.join(' '), ctx).map_err(function(e) {
        return Result.err("expected a list");
      }).map(function(proc) {
        return Result.wrap(List.uniq(ls, proc));
      }) : Result.wrap(List.uniq(ls, cmp))).map_err(function(e) {
        return Result.err("uniq: " + e);
      });
    },
    help__wrap: function() {
      return "wrap &lt;value&gt;\n\nThis just turns a coffeescript expression into a result object\nthat can be used to feed data through a pipeline of\ncommands. This function is called implicitly when you start a\ncommand line out with a coffeescript expression instead of a\ncommand.\n\nThese two examples are identical in their behavior internally:\n\nExamples:\n  $ wrap [1,2,3]\n  [1,2,3]\n\n  $ [1,2,3]\n  [1,2,3]";
    },
    wrap: (function(_this) {
      return function(argv, data, ctx) {
        return Utils.parsevalue(argv.join(" "), ctx).map_err(function(e) {
          return Result.err("wrap: " + e);
        });
      };
    })(this),
    help__nest: function() {
      return "nest &lt;path_function&gt;\n\nnest works like group, except that your function should return\na list of keys to use like a filesystem path. Each item in the\ndata set will be placed into an object hierarchy so that its\nkey list will locate it uniqely. This is useful for making\ntree structures.\n\nExample:\n    $ [1,2,3,4,5] \\ nest (n) -> [\n        (if n > 3 then 'large' else 'small'),\n        (if n % 2 == 0 then 'even' else 'odd')]\n    {\n       large: {even: [4], odd:[5]},\n       small: {even: [2], odd: [1,3]}\n    }\n\nNote: If you get the message 'expected a function', ensure\nthat you have any if/else statements that are used like\nexpressions surrounded by parentheses. Coffeescript fails to\nparse the expression otherwise. The if statements in the\nexample demonstrate how to do this. ";
    },
    nest: (function(_this) {
      return function(argv, d, ctx) {
        return (Utils.parsefunction(argv.join(" "), ctx).map_err(function(e) {
          return Result.err("expected a function");
        }).map(function(pathmkr) {
          var e;
          try {
            return Result.wrap(List.nest(d, pathmkr));
          } catch (error) {
            e = error;
            return Result.err('' + e);
          }
        })).map_err(function(e) {
          if (('' + e === 'expected a function') && (argv.join(' ')).indexOf("if") !== -1) {
            return Result.err("nest: " + e + ' (ensure all "if" expressions are surrounded by parentheses)');
          } else {
            return Result.err("nest: " + e);
          }
        });
      };
    })(this),
    help__bfs: function() {
      return "bfs &lt;func(item)&gt;\n\nbfs traverses a nested list or object in breadth-first\nfashion, calling the function on each element and appending\nits return value to a list (which will be in breadth-first\norder.\n\nExamples:\n    $ [1,[4,[9,10,11],5],2,[6,7,8],3] \\ bfs (x)-> x\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n\n    $ {a: 1, b: [1,2,3], c: {d: 5, e: 6}} \ bfs (x,p) -> '['+(p.join ',')+']' + '=' + x\n    ['[a]=1', '[b]=1,2,3', '[c,d]=5', '[c,e]=6']";
    },
    bfs: (function(_this) {
      return function(argv, d, ctx) {
        return (Utils.parsefunction(argv.join(" "), ctx).map_err(function(e) {
          return Result.err("expected a function");
        }).map(function(proc) {
          var e;
          try {
            if (Utils.isArray(d)) {
              return Result.wrap(List.bfs(d, proc));
            } else if (Utils.isObject(d)) {
              return Result.wrap(Struct.bfs(d, proc));
            } else {
              return Result.wrap(proc(d));
            }
          } catch (error) {
            e = error;
            return Result.err('' + e);
          }
        })).map_err(function(e) {
          return Result.err("bfs: " + e);
        });
      };
    })(this),
    help__histogram: function() {
      return "histogram\n\nCompute the histogram of the data. Expects the data to be in a\nlist format where each element is an instance of one of the\nbins to be counted. The result is returned as an object with\none key for each unique element, and a count of the instances\nof that element as the value.\n\nExample:\n    $ [1,1,1,2,3,3,3,4,4,4,4,4] \ pdf\n    {1:3, 2: 1, 3: 3, 4: 5}\n";
    },
    histogram: (function(_this) {
      return function(argv, d, ctx) {
        var e;
        return ((function() {
          try {
            return Result.wrap(List.histogram(d));
          } catch (error) {
            e = error;
            return Result.err('' + e);
          }
        })()).map_err(function(e) {
          return Result.err("pdf: " + e);
        });
      };
    })(this),
    help__tabulate: function() {
      return "tabulate [basevalue]\n\ntabulate fills out a 2d table from a sparse representation of\nthe table. Assuming you have an object, which has a number of\nkeys whose associated values are also objects, tabulate will\niterate through all keys and subkeys to collect all of the row\nidentifiers and column identifiers. It will then generate a\ntable that includes *all* rows and columns from all data\nelements, with the elements themselves populated at the\nappropriate positions. An example of using this might be to\ntransform an association list representation of a network into\na full association matrix. For example, if you have data that\ntells you when messages have passed between various hosts on a\nnetwork, use the pipe system to work that data into an object\nwith a key for each entity that has sent a message, and a\nvalue that's an object with a key for each entity that the\nsender has sent *to*. Then, pipe that data into tabulate, and\nit will generate a full table for you so that you can render\nit or further manipulate it in a normalized way.\n\nbasevalue is optional, and allows you to either generate a\nlist-structured table or an object-structured table. It\ndefaults to object-structured.\n\nExample (association matrix of communicating hosts):\n    $ get \"http://somewhere.com/messages.json\" \\\n    .. group (msg)->msg.sender \\\n    .. mapkeys (sender, receivers) -> List.group receivers, (msg)->msg.receiver \\\n    .. tabulate\n\nThe example will fetch a list of messages from some server,\nthen group them by sender (this returns an object with a key\nfor each unique sender, and a list of all messages that sender\nsent). It then iterates over the senders in that object to\nfurther group the messages by receiver. The object now has the\nstructure obj[sender][receiver] = [list of messages]. This is\npassed to tabulate, which generates a full 2d table and puts\nthe message lists in the appropriate row and column. At this\npoint you could easily generate a heatmap from the data to\nshow which hosts are talking most frequently, or do some other\nprocessing to it that takes advantage of the full table\nstructure.";
    },
    tabulate: (function(_this) {
      return function(argv, data, ctx) {
        return (Utils.parsevalue(argv, ctx)).map(function(baseval) {
          var base, col, cols, e, i, j, k, key, len, len1, len2, ref1, result, row, rows;
          if (baseval == null) {
            baseval = {};
          }
          try {
            rows = ((function() {
              var results;
              results = [];
              for (key in data) {
                if (!hasProp.call(data, key)) continue;
                results.push(key);
              }
              return results;
            })()).sort();
            cols = {};
            result = {};
            for (i = 0, len = rows.length; i < len; i++) {
              row = rows[i];
              ref1 = data[row];
              for (col in ref1) {
                if (!hasProp.call(ref1, col)) continue;
                cols[col] = true;
              }
            }
            cols = ((function() {
              var results;
              results = [];
              for (key in cols) {
                if (!hasProp.call(cols, key)) continue;
                results.push(key);
              }
              return results;
            })()).sort();
            for (j = 0, len1 = rows.length; j < len1; j++) {
              row = rows[j];
              for (k = 0, len2 = cols.length; k < len2; k++) {
                col = cols[k];
                if (result[row] == null) {
                  result[row] = {};
                }
                if ((base = result[row])[col] == null) {
                  base[col] = baseval;
                }
                if (data[row][col]) {
                  result[row][col] = data[row][col];
                }
              }
            }
            return Result.wrap(result);
          } catch (error) {
            e = error;
            return Result.err(e);
          }
        }).map_err(function(e) {
          return Result.err("tabulate: " + e);
        });
      };
    })(this),
    help__deepmap: function() {
      return "deepmap <proc>\n\nApply proc to every element of a nested data structure. The\nstructure can be either a list or an object. In both cases, an\nitem is considered to be a leaf when it's not the same type as\nthe overall object (so anything that's not an object is a leaf\nfor the object, and anything that's not an array is a leaf for\nthe array version). The resulting value will mirror the\noriginal structure, but the values will all be replaced with\nthe result of running proc on the original value in that\nplace.\n\nExample:\n    $ [[1,[2,3],4],5] \\ deepmap (n)->n*2\n    [[2,[4,6],8],10]";
    },
    deepmap: (function(_this) {
      return function(argv, d, ctx) {
        return (Utils.parsefunction(argv.join(' ', ctx))).map(function(proc) {
          if (Utils.isArray(d)) {
            return Result.wrap(List.deepmap(d, proc));
          } else {
            return Result.wrap(Struct.deepmap(d, proc));
          }
        }).map_err(function(e) {
          return Result.err("deepmap: " + e);
        });
      };
    })(this),
    help__cmb: function() {
      return "cmb <n> \n\nAccept a list from the pipeline and generate all possible\ncombinations of n items from the list. This is useful for\nsituations where you want to generate a network diagram and\nyou have lists of things that should be connected with each\nother. Just set n to 2 and you're done.\n\nThis treats different orderings of the pair as different\nentities, so [2,3] is not the same as [3,2].\n\nExample:\n    $ [1,2,3] \\ cmb 2\n    [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]";
    },
    cmb: (function(_this) {
      return function(argv, d, ctx) {
        return (Utils.parsevalue(argv.join(' ', ctx))).map(function(ct) {
          return Result.wrap(List.cmb(d, ct));
        }).map_err(function(e) {
          return Result.err("cmb: " + e);
        });
      };
    })(this),
    help__window: function() {
      return "window n proc\n\nSliding window calculation - starting at data[0...n], call\nproc on those n elements for each element up to\ndata.length-n. The result is a list of data.length-n items\nrepresenting the result of the function call on each sublist.\n\nExample:\n    $ [0...10] \\ window 3 (a,b,c)->a+b+c\n    [3, 6, 9, 12, 15, 18, 21]\n\nThe example just sums the current three elements for every\nconsecutive group of three elements in the list. The input\nlist is ten elements, and the output list is seven. ";
    },
    window: (function(_this) {
      return function(argv, d, ctx) {
        return (Utils.parsevalue(argv[0], ctx)).map(function(n) {
          return (Utils.parsefunction(argv.slice(1).join(' ', ctx))).map(function(proc) {
            return Result.wrap(List.window(d, n, proc));
          });
        }).map_err(function(e) {
          return Result.err("window: " + e);
        });
      };
    })(this),
    help__intersect: function() {
      return "intersect [proc]\n\nintersect finds all of the elements in common between all\nitems in a list of lists or objects. It treats the input as a\nset of sets and computes the intersection of all of them. The\nproc argument is optional, and can be used to specify how to\ndecide which items are equal by providing a name based on the\nitem. For example, if you have a set of lists of groups of\nnumbers, you could specify proc to just sum the numbers in a\ngroup. The intersection would then be calculated based on that\nsum as the identifying property of each group.\n\nThe result returned is an object that has keys for each\nidentified item (result of calling proc), and a list of the\nitems from each set that matched.\n\nIf you have multiple items within a single set that map to the\nsame identifier, you will get unexpected results. The\ncolliding items will count separately toward the intersection\ngoal, so you may get extra elements in the corresponding list,\nor you may get some elements that don't appear in all sets.\n\nExample:\n    $ [[[1..3],[6],[2,3]],[[2,4],[5]],[[6],[5],[2,3,4]]] \\\n    .. intersect (ls)->ls.reduce (a,b)->a+b\n    {\n      5: {count: 3, items: [[2, 3], [5], [5]]},\n      6: {count: 4, items: [[1, 2, 3], [6], [2, 4], [6]]}\n    }\n            \nIn the example, note that the group that sums to 6 has four\nitems even though there are only three sets involved. This\nhappened because the first set has two items that sum to six\n(the [1..3] group and the [6])";
    },
    intersect: (function(_this) {
      return function(argv, data, ctx) {
        var proc;
        proc = null;
        if (argv.length > 0) {
          proc = Utils.parsefunction(argv.join(' ', ctx));
        } else {
          proc = Utils.parsefunction('(x)->x');
        }
        return proc.map(function(p) {
          return Result.wrap(List.intersect(data, p));
        }).map_err(function(e) {
          return Result.err("intersect: " + e);
        });
      };
    })(this),
    help__select: function() {
      return "select [list,of,keys]\n\nSelect lets you pick only specific items out of an indexable\nobject (array or struct). Provide a coffeescript formatted\nlist on the command line (this will be evaluated, so it can be\ndata from other sources, or even the result of a function\ncall, etc). The returned data will have only the fields\nspecified. If fields are specified but not present in the\ninput, they will be ignored.\n\nExample:\n    $ {a: 1,b:2, c:3} \\ select ['a','c','d']\n    {a: 1, c:3}\n\nIn the example, fields a and c are picked, but there is no d\nin the input so it is ignored. Field b is removed.";
    },
    select: (function(_this) {
      return function(argv, data, ctx) {
        return Utils.parsevalue(argv.join(' ', ctx)).map(function(idx) {
          if (Utils.isArray(data)) {
            return Result.wrap(List.select(data, idx));
          } else {
            return Result.wrap(Struct.select(data, idx));
          }
        }).map_err(function(e) {
          return Result.err("select: " + e);
        });
      };
    })(this)
  };

  module.exports = BaseCommands;

}).call(this);

//# sourceMappingURL=base-commands.js.map
