// Generated by CoffeeScript 1.11.1
(function() {
  var History, Result, ResultPromise, Shell, Utils, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  History = require('./history.js');

  Utils = require('./utils.js');

  ref = require('./result.js'), Result = ref.Result, ResultPromise = ref.ResultPromise;

  Shell = (function() {
    function Shell(output) {
      this.output = output;
      this.getCommands = bind(this.getCommands, this);
      this.clearHistory = bind(this.clearHistory, this);
      this.clearContext = bind(this.clearContext, this);
      this.prettyprint = bind(this.prettyprint, this);
      this.doCompletion = bind(this.doCompletion, this);
      this.complete = bind(this.complete, this);
      this.runCommands = bind(this.runCommands, this);
      this.doCommand = bind(this.doCommand, this);
      this.registerEditor = bind(this.registerEditor, this);
      this.history = new History();
      if (this.output == null) {
        this.output = function(s) {
          return alert("Warning- output function not defined!!!\n\n" + s);
        };
      }
      this.commands = {};
      this.docs = {};
      this.scope = {};
      this.context = {};
      this.addCommands(this.getCommands());
      this.editor = void 0;
    }

    Shell.prototype.registerEditor = function(ed) {
      ed.setCompletionHandler(this.doCompletion);
      ed.setCommandHandler(this.doCommand);
      return this.editor = ed;
    };

    Shell.prototype.loadSavedData = function() {
      var func, item, j, len1, recovered, ref1, ref2, results;
      this.context.__functions = [];
      recovered = JSON.parse(localStorage.getItem('context'));
      if (recovered) {
        this.context = recovered;
        if (this.context.__functions) {
          ref1 = this.context.__functions;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            func = ref1[j];
            Utils.parsefunction(func.source, this.context).and_then((function(_this) {
              return function(f) {
                return _this.context[func.name] = f;
              };
            })(this)).map_err((function(_this) {
              return function(e) {
                return console.log("Error recovering function " + func.name + ": " + e);
              };
            })(this));
          }
        } else {
          this.context.__functions = [];
        }
      }
      ref2 = this.scope;
      results = [];
      for (item in ref2) {
        if (!hasProp.call(ref2, item)) continue;
        results.push(this.context[item] = this.scope[item]);
      }
      return results;
    };

    Shell.prototype.addCommands = function(cmds) {
      var cmd, handler, name, results;
      results = [];
      for (cmd in cmds) {
        handler = cmds[cmd];
        if (cmd.startsWith("help__")) {
          name = cmd.slice(6);
          if (name) {
            results.push(this.docs[name] = handler);
          } else {
            results.push(void 0);
          }
        } else {
          results.push(this.commands[cmd] = handler);
        }
      }
      return results;
    };

    Shell.prototype.addScope = function(items) {
      var item, results;
      results = [];
      for (item in items) {
        if (!hasProp.call(items, item)) continue;
        results.push(this.scope[item] = items[item]);
      }
      return results;
    };

    Shell.prototype.splitCommands = function(cmd) {
      var i, re, splits;
      re = /[^\\]\\[^\\]/g;
      splits = [-2];
      i = 0;
      while ((i = re.exec(cmd))) {
        splits.push(i.index);
      }
      splits.push(cmd.length);
      return ((function() {
        var j, ref1, results;
        results = [];
        for (i = j = 0, ref1 = splits.length - 1; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
          results.push(cmd.slice(splits[i] + 2, splits[i + 1] + 1));
        }
        return results;
      })()).map(function(c) {
        return c.trim();
      }).map(function(c) {
        return c.split(' ');
      }).map(function(c) {
        return c.map(function(s) {
          return s.replace("\\\\", "\\");
        });
      });
    };

    Shell.prototype.doCommand = function(cmd) {
      var cmds, data, i, j, len1;
      cmds = this.splitCommands(cmd);
      data = Result.wrap({});
      i = 0;
      for (j = 0, len1 = cmds.length; j < len1; j++) {
        cmd = cmds[j];
        if (!(cmd[0] in this.commands)) {
          if (i === 0) {
            cmd.unshift("wrap");
          } else {
            cmd.unshift("map");
          }
        }
        i = 1;
      }
      return this.runCommands(data, cmds);
    };

    Shell.prototype.runCommands = function(data, cmds) {
      var cmd, e, i, j, ref1;
      for (i = j = 0, ref1 = cmds.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        cmd = cmds[i];
        try {
          data = data.map((function(_this) {
            return function(d) {
              _this.context._ = d;
              return _this.commands[cmd[0]](cmd.slice(1), d, _this.context);
            };
          })(this));
        } catch (error) {
          e = error;
          data = Result.err(cmds[i] + ': ' + e);
          console.log(e);
        }
        console.log(data);
        if (data instanceof ResultPromise) {
          data.progress(((function(_this) {
            return function(done, total) {
              console.log("Progress: " + done + "/" + total);
              return _this.editor.progress(done, total);
            };
          })(this))).map((function(_this) {
            return function(result) {
              return _this.runCommands(Result.wrap(result), cmds.slice(i + 1));
            };
          })(this));
          data.map_err((function(_this) {
            return function(msg) {
              return _this.showError(msg);
            };
          })(this));
          return;
        } else if (data.is_err()) {
          break;
        }
      }
      return data.map_err((function(_this) {
        return function(e) {
          return _this.showError(e);
        };
      })(this)).and_then((function(_this) {
        return function(d) {
          var result;
          result = (_this.prettyprint(d)) + '\n';
          return _this.output(result);
        };
      })(this));
    };

    Shell.prototype.showError = function(msg) {
      this.output(msg + "\n");
      return Result.err(msg);
    };

    Shell.prototype.complete = function(commands, stub) {
      var c, j, len1;
      for (j = 0, len1 = commands.length; j < len1; j++) {
        c = commands[j];
        if (c.startsWith(stub)) {
          return c;
        }
      }
      return stub;
    };

    Shell.prototype.doCompletion = function(stub) {
      var cmd, cmds, othercmd;
      cmds = this.splitCommands(stub);
      cmd = cmds[cmds.length - 1];
      othercmd = cmds.slice(0, -1);
      if (!cmd || cmd.length > 1) {
        return stub;
      } else {
        return ((othercmd.map(function(c) {
          return c.join(' ');
        })).join(' \\ ')).concat([this.complete(Object.keys(this.commands), cmd[0])].join(' \\ '));
      }
    };

    Shell.prototype.prettyprint = function(data) {
      var indented, oneliner;
      oneliner = function(strs) {
        var j, len, len1, s;
        len = 0;
        for (j = 0, len1 = strs.length; j < len1; j++) {
          s = strs[j];
          if (indexOf.call(s, '\n') >= 0) {
            return false;
          }
          len += s.length;
        }
        return len <= 80;
      };
      indented = function(n, ob) {
        var k, keys, ls, pairs, s, spaces;
        s = "";
        if (Utils.isArray(ob)) {
          ls = ob.map(function(o) {
            return indented(n + 2, o);
          });
          if (oneliner(ls)) {
            s = '[' + ls.join(", ") + ']';
          } else {
            s = '[\n' + (' '.repeat(n + 2)) + ls.join(",\n" + ' '.repeat(n + 2)) + '\n' + (' '.repeat(n)) + ']';
          }
          return s;
        } else if (typeof ob === 'undefined') {
          return 'undefined';
        } else if (ob === null) {
          return 'null';
        } else if (typeof ob === 'object') {
          keys = ((function() {
            var results;
            results = [];
            for (k in ob) {
              if (!hasProp.call(ob, k)) continue;
              results.push(k);
            }
            return results;
          })()).sort();
          pairs = keys.map(function(k) {
            return k + ': ' + (!k.startsWith('__') ? indented(n + 2, ob[k]) : "<internal>");
          });
          if (oneliner(pairs)) {
            s = '{' + pairs.join(", ") + "}";
          } else {
            spaces = ' '.repeat(n + 2);
            s = '{\n' + spaces + pairs.join(',\n' + spaces) + '\n' + spaces.slice(0, -2) + '}';
          }
          return s;
        } else if (typeof ob === 'function') {
          return '[function]';
        } else {
          return JSON.stringify(ob);
        }
      };
      return indented(0, data);
    };

    Shell.prototype.clearContext = function() {
      localStorage.setItem('context', JSON.stringify({}));
      this.context = {};
      this.loadSavedData();
      return Result.wrap(this.context);
    };

    Shell.prototype.clearHistory = function() {
      this.history.clear();
      return Result.wrap({});
    };

    Shell.prototype.getCommands = function() {
      return {
        help: (function(_this) {
          return function(argv, data, ctx) {
            var cmd, columns, getcols, str;
            getcols = function(maxw, ncols, index) {
              var col, cols, i, j, n, ref1, width;
              col = 0;
              cols = [];
              width = 0;
              for (i = j = 0, ref1 = ncols; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
                n = col;
                while (index[n][0] % ncols !== i) {
                  n++;
                }
                col = n;
                cols.push(index[col][1]);
                width += cols[i];
                if (width > maxw) {
                  return null;
                }
              }
              return cols;
            };
            columns = function(maxw, items) {
              var cols, index, item, len, maxcols, pos;
              index = ((function() {
                var j, len1, results;
                results = [];
                for (pos = j = 0, len1 = items.length; j < len1; pos = ++j) {
                  item = items[pos];
                  results.push([pos, item.length]);
                }
                return results;
              })()).sort(function(a, b) {
                return b[1] - a[1];
              });
              len = 0;
              maxcols = 0;
              while (len + items[maxcols] < maxw) {
                len += items[maxcols].length;
                maxcols++;
              }
              while (maxcols > 1) {
                cols = getcols(maxw, maxcols, index);
                if (cols) {
                  return cols;
                }
              }
              return [maxw];
            };
            cmd = "";
            if (argv.length > 0) {
              cmd = argv[0];
            }
            if (cmd in _this.docs && cmd !== "help") {
              return Result.err(_this.docs[cmd]());
            } else {
              str = "";
              if (cmd !== "" && !(cmd in _this.commands)) {
                str += "Command \"" + cmd + "\" is unrecognized\n";
              } else if (cmd !== "") {
                str += "Sorry, \"" + cmd + "\" does not have documentation yet";
              }
              str += "Read-Eval-Visualize-Loop (REVL)\n    \nREVL is a tool to make it easier to transform data\ninto a format that can be run through a\nvisualization.  It's built to behave like a\ncommand line, in that you can pipe data through\nvarious primitive operations to transform\nit from the source format into a format that can\nbe dumped into one of the visualization tools.\n\nUse a single backslash ('\\') to separate commands\nas you would use the pipe character on a standard\ncommand line. Each command has help specifically\nwritten for it as well. To view the help for a\nspecific command, type 'help <command>' where\n<command> is replace with the name of the command\nyou need help with. Every command includes at\nleast one example of how to use it in a realistic\ncontext.\n\nSome commands take parameters on the command line,\nand many take function literals to be run on the\ndata being piped though. Command line arguments\nshould be written in coffeescript syntax (see\nhttp://coffeescript.org for details).\n\nYou will often want to access library features\nfrom within pipeline functions. These are\ngenerally available under the name of the module\nthey come from (Struct,Strings,Poly,etc). The only\nexception is the list features, which are directly\nimported without a namespace because they are so\ncommonly used.\n\nYou can also access the current pipeline data from\nthe command line context using the special name\n'_'. This allows you to use piped data as initial\nvalues, and to use parts of the global data\nstructure from within iterator commands like fold.\n\nThe commands currently supported in this system\nare:\n\t" + (Object.keys(_this.commands)).sort().join("\n\t");
              return Result.err(str);
            }
          };
        })(this),
        help__store: function() {
          return "store &lt;name&gt;\n    \nstore the current data item in the shell under the given\nname. It can be used from that point forward to recall the\nvalue inside other expressions.";
        },
        store: (function(_this) {
          return function(argv, data, ctx) {
            if (argv.length !== 1) {
              return Result.err("store expects input from a pipe, and a name from the command line");
            } else {
              _this.context[argv[0]] = data;
              localStorage.setItem('context', JSON.stringify(_this.context));
              return Result.wrap(data);
            }
          };
        })(this),
        help__clear: function() {
          return "clear [-h]\n    \nIf -h is supplied, clear command history. Otherwise, clear all\nstored variables from the shell. This also clears your local\nstorage, so the variables (or history) will not reappear if\nyou reload. Use with caution!  ";
        },
        clear: (function(_this) {
          return function(argv, data, ctx) {
            if (argv.length > 0 && argv[0] === '-h') {
              return _this.clearHistory();
            } else {
              return _this.clearContext();
            }
          };
        })(this),
        help__history: function() {
          return "history\n    \nReturn the list of commands currently held in the history\nobject.";
        },
        history: (function(_this) {
          return function(argv, data, ctx) {
            return Result.wrap(_this.history.all());
          };
        })(this),
        help__context: function() {
          return "context\n    \ncontext prints out the set of variables that are currently\ndefined in the shell.";
        },
        context: (function(_this) {
          return function(argv, data, ctx) {
            return Result.wrap(_this.context);
          };
        })(this),
        help__define: function() {
          return "define &lt;name&gt; &lt;value&gt;\n    \nThis is another way to add a value to the context. If you want\nto have a function stored in the context, you should use this\nmethod. Using the store command will work, but only until you\nend your session. With the define command, the source code of\nthe function is saved in the browser's localstorage object so\nthat the function can be recompiled when the session is\nreloaded.\n    \nExample:\n    $ define sum (args...)->List.foldl args 0, (a,b)->a+b\n    [function]";
        },
        define: (function(_this) {
          return function(argv, data, ctx) {
            var name, src;
            name = argv[0];
            src = argv.slice(1).join(' ');
            return (Utils.parsevalue(src)).map(function(val) {
              ctx[name] = val;
              if ((typeof val) === 'function') {
                ctx.__functions.push({
                  name: name,
                  source: src
                });
                localStorage.setItem('context', JSON.stringify(ctx));
              }
              return Result.wrap(val);
            }).map_err(function(e) {
              return Result.err('define: ' + e);
            });
          };
        })(this)
      };
    };

    return Shell;

  })();

  module.exports = Shell;

}).call(this);

//# sourceMappingURL=shell.js.map
