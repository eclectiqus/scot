'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var DEFAULT_ROOT_PATH = exports.DEFAULT_ROOT_PATH = '$';

/* should be modified to support __proto__ */
var isExpandable = exports.isExpandable = function isExpandable(data) {
  return (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data !== null && Object.keys(data).length > 0;
};

var getPathsState = exports.getPathsState = function getPathsState(expandLevel, expandPaths, data, rootName) {
  var initialState = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];

  var wildcardPaths = [];
  var rootPath = DEFAULT_ROOT_PATH;
  if (expandLevel !== undefined) {
    wildcardPaths = wildcardPaths.concat(wildcardPathsFromLevel(expandLevel));
  }

  wildcardPaths = wildcardPaths.concat(expandPaths);

  var paths = pathsFromWildcardPaths(wildcardPaths, data, rootPath);
  var pathsState = paths.reduce(function (obj, path) {
    obj[path] = true;return obj;
  }, initialState);

  return pathsState;
};

/**
 * Convert wild card paths to concrete paths
 * @param  {array} initialExpandedPaths  wild card paths
 * @param  {object} data                 data object
 * @param  {string} rootName             optional root name (if not specified will use DEFAULT_ROOT_PATH)
 * @return {array}                       concrete paths
 */
var pathsFromWildcardPaths = exports.pathsFromWildcardPaths = function pathsFromWildcardPaths(wildcardPaths, data) {
  var paths = [];
  var rootPath = DEFAULT_ROOT_PATH;
  if (wildcardPaths === undefined) {
    return paths;
  }
  wildcardPaths.map(function (wildcardPath) {
    if (typeof wildcardPath === 'string') {
      (function () {
        // wildcard names
        // recursively populate paths with wildcard paths

        var populatePaths = function populatePaths(curObject, curPath, i) {
          var WILDCARD = "*";
          if (i === names.length) {
            paths.push(curPath);
            return;
          }
          var name = names[i];
          if (i === 0) {
            if (isExpandable(curObject) && (name === rootPath || name === WILDCARD)) {
              populatePaths(curObject, rootPath, i + 1);
            }
          } else {
            if (name === WILDCARD) {
              // matches anything
              for (var propertyName in curObject) {
                if (curObject.hasOwnProperty(propertyName)) {
                  var propertyValue = curObject[propertyName];
                  if (isExpandable(propertyValue)) {
                    populatePaths(propertyValue, curPath + '.' + propertyName, i + 1);
                  } else {
                    continue;
                  }
                }
              }
            } else {
              var propertyValue = curObject[name];
              if (isExpandable(propertyValue)) {
                populatePaths(propertyValue, curPath + '.' + name, i + 1);
              }
            }
          }
        };

        var names = wildcardPath.split('.');
        populatePaths(data, '', 0);
      })();
    }
  });
  return paths;
};

var wildcardPathsFromLevel = exports.wildcardPathsFromLevel = function wildcardPathsFromLevel(level) {
  if (level < 0) {
    return undefined;
  }
  if (level === 0) {
    return [];
  }
  var rootPath = DEFAULT_ROOT_PATH;
  var path = rootPath;
  var wildcardPaths = [path];
  for (var i = 1; i < level; i++) {
    path += '.*';
    wildcardPaths.push(path);
  }
  return wildcardPaths;
};

var pathsFromDataAndLevel = exports.pathsFromDataAndLevel = function pathsFromDataAndLevel(data, level) {
  var wildcardPaths = wildcardPathsFromLevel(level);
  return pathsFromWildcardPaths(wildcardPaths, data);
};